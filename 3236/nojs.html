<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 Survival Game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif; }
        canvas { display: block; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background-color: white; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #hud { position: absolute; bottom: 10px; left: 10px; color: white; background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        #quickBar { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; background-color: rgba(0,0,0,0.6); padding: 5px; border-radius: 5px; }
        .quickSlot { width: 50px; height: 50px; border: 1px solid #ccc; margin: 2px; background-color: rgba(255,255,255,0.2); color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; text-align: center; position: relative; }
        .quickSlot.selected { border: 2px solid yellow; }
        .quickSlot .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 12px; font-weight: bold; background: rgba(0,0,0,0.7); padding: 0 3px; border-radius: 3px;}
        #inventory, #craftingMenu, #settingsMenu, #containerView { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0,0,0,0.85); color: white; padding: 20px; border-radius: 10px; display: none; border: 1px solid #555; max-height: 80vh; overflow-y: auto; }
        #inventory h2, #craftingMenu h2, #settingsMenu h2, #containerView h2 { margin-top: 0; text-align: center; }
        .inventoryGrid, .containerGrid { display: grid; grid-template-columns: repeat(5, 60px); gap: 5px; margin-top: 10px; }
        .inventorySlot, .containerSlot { width: 55px; height: 55px; border: 1px solid #555; background-color: rgba(255,255,255,0.1); display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; text-align: center; position: relative; cursor: pointer; }
        .inventorySlot:hover, .containerSlot:hover { background-color: rgba(255,255,255,0.2); }
        .inventorySlot .item-count, .containerSlot .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 12px; font-weight: bold; background: rgba(0,0,0,0.7); padding: 0 3px; border-radius: 3px;}
        .craftingItem { background: #444; padding: 5px 10px; margin: 5px 0; border-radius: 3px; cursor: pointer; }
        .craftingItem:hover { background: #555; }
        .craftingItem.canCraft { background: #3a3; }
        .craftingItem.canCraft:hover { background: #4b4; }
        #interactionPrompt { position: absolute; top: 60%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 8px 15px; border-radius: 5px; display: none; pointer-events: none; }
        #settingsMenu label, #settingsMenu input { display: block; margin: 10px 0; }
        #settingsMenu button { padding: 10px 20px; margin-top: 15px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="settingsMenu">
        <h2>Game Settings</h2>
        <label for="startResources">Starting Resources (Wood, Stone):</label>
        <input type="number" id="startResources" value="10" min="0">
        <label for="playerSpeed">Player Speed:</label>
        <input type="number" id="playerSpeed" value="5" min="1" step="0.5">
        <label for="playerHeight">Player Height:</label>
        <input type="number" id="playerHeight" value="1.8" min="0.5" step="0.1">
        <button id="startGameBtn">Start Game</button>
    </div>

    <div id="crosshair">+</div>
    <div id="hud">
        Health: <span id="health">100</span> | Hunger: <span id="hunger">100</span> | Thirst: <span id="thirst">100</span>
        <br>
        Equipped: <span id="equippedItem">None</span>
    </div>
    <div id="quickBar">
        <!-- Slots generated by JS -->
    </div>
    <div id="inventory">
        <h2>Inventory</h2>
        <div class="inventoryGrid">
            <!-- Slots generated by JS -->
        </div>
    </div>
    <div id="craftingMenu">
        <h2>Crafting</h2>
        <div id="craftingList">
            <!-- Recipes generated by JS -->
        </div>
    </div>
     <div id="containerView">
        <h2 id="containerTitle">Container</h2>
        <div class="containerGrid">
            <!-- Slots generated by JS -->
        </div>
    </div>
    <div id="interactionPrompt">Press [E] to interact</div>

    <canvas id="gameCanvas"></canvas>

    <!-- THREE.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- PointerLockControls for FPS movement -->
    <script>
        /**
         * @author mrdoob / http://mrdoob.com/
         * @author Mugen87 / https://github.com/Mugen87
         */

        THREE.PointerLockControls = function ( camera, domElement ) {

        	this.domElement = domElement || document.body;
        	this.isLocked = false;

        	// Set to constrain the pitch of the camera
        	// Range is 0 to Math.PI radians
        	this.minPolarAngle = 0; // radians
        	this.maxPolarAngle = Math.PI; // radians

        	// Internals

        	var scope = this;

        	var changeEvent = { type: 'change' };
        	var lockEvent = { type: 'lock' };
        	var unlockEvent = { type: 'unlock' };

        	var euler = new THREE.Euler( 0, 0, 0, 'YXZ' );

        	var PI_2 = Math.PI / 2;

        	var vec = new THREE.Vector3();

        	function onMouseMove( event ) {

        		if ( scope.isLocked === false ) return;

        		var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        		var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

        		euler.setFromQuaternion( camera.quaternion );

        		euler.y -= movementX * 0.002;
        		euler.x -= movementY * 0.002;

        		euler.x = Math.max( PI_2 - scope.maxPolarAngle, Math.min( PI_2 - scope.minPolarAngle, euler.x ) );

        		camera.quaternion.setFromEuler( euler );

        		scope.dispatchEvent( changeEvent );

        	}

        	function onPointerlockChange() {

        		if ( document.pointerLockElement === scope.domElement ) {

        			scope.dispatchEvent( lockEvent );

        			scope.isLocked = true;

        		} else {

        			scope.dispatchEvent( unlockEvent );

        			scope.isLocked = false;

        		}

        	}

        	function onPointerlockError() {

        		console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' );

        	}

        	this.connect = function () {

        		document.addEventListener( 'mousemove', onMouseMove, false );
        		document.addEventListener( 'pointerlockchange', onPointerlockChange, false );
        		document.addEventListener( 'pointerlockerror', onPointerlockError, false );

        	};

        	this.disconnect = function () {

        		document.removeEventListener( 'mousemove', onMouseMove, false );
        		document.removeEventListener( 'pointerlockchange', onPointerlockChange, false );
        		document.removeEventListener( 'pointerlockerror', onPointerlockError, false );

        	};

        	this.dispose = function () {

        		this.disconnect();

        	};

        	this.getObject = function () { // retaining this method for backward compatibility

        		return camera;

        	};

        	this.getDirection = function () {

        		var direction = new THREE.Vector3( 0, 0, - 1 );

        		return function ( v ) {

        			return v.copy( direction ).applyQuaternion( camera.quaternion );

        		};

        	}();

        	this.moveForward = function ( distance ) {

        		// move forward parallel to the xz-plane
        		// assumes camera.up is y-up

        		vec.setFromMatrixColumn( camera.matrix, 0 );

        		vec.crossVectors( camera.up, vec );

        		camera.position.addScaledVector( vec, distance );

        	};

        	this.moveRight = function ( distance ) {

        		vec.setFromMatrixColumn( camera.matrix, 0 );

        		camera.position.addScaledVector( vec, distance );

        	};

        	this.lock = function () {

        		this.domElement.requestPointerLock();

        	};

        	this.unlock = function () {

        		document.exitPointerLock();

        	};

        	this.connect();

        };

        THREE.PointerLockControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        THREE.PointerLockControls.prototype.constructor = THREE.PointerLockControls;

    </script>

    <!-- Game Logic -->
    <script>
        let scene, camera, renderer, controls;
        let player = {
            height: 1.8,
            speed: 5.0,
            turnSpeed: Math.PI * 0.02,
            canJump: true,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            health: 100,
            hunger: 100,
            thirst: 100,
            inventory: [], // { name: 'Wood', quantity: 10 }
            quickBar: new Array(5).fill(null), // Size 5 quick bar
            selectedQuickSlot: 0,
            isInventoryOpen: false,
            isCraftingOpen: false,
            isContainerOpen: false,
            interactingWith: null // Reference to the object being interacted with (e.g., barrel, crate)
        };
        const objects = []; // Collidable world objects
        const resources = []; // Resource nodes (trees, rocks, grass)
        const animals = []; // Simple animal representations
        const placeables = []; // Campfires, workbenches etc.
        const containers = []; // Barrels, crates

        const clock = new THREE.Clock();
        const moveForward = { value: false };
        const moveBackward = { value: false };
        const moveLeft = { value: false };
        const moveRight = { value: false };
        const jump = { value: false };

        const interactionDistance = 4;
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2(0, 0); // Center of screen

        // DOM Elements
        const healthEl = document.getElementById('health');
        const hungerEl = document.getElementById('hunger');
        const thirstEl = document.getElementById('thirst');
        const equippedItemEl = document.getElementById('equippedItem');
        const inventoryEl = document.getElementById('inventory');
        const inventoryGridEl = inventoryEl.querySelector('.inventoryGrid');
        const quickBarEl = document.getElementById('quickBar');
        const craftingMenuEl = document.getElementById('craftingMenu');
        const craftingListEl = document.getElementById('craftingList');
        const interactionPromptEl = document.getElementById('interactionPrompt');
        const settingsMenuEl = document.getElementById('settingsMenu');
        const startGameBtn = document.getElementById('startGameBtn');
        const containerViewEl = document.getElementById('containerView');
        const containerGridEl = containerViewEl.querySelector('.containerGrid');
        const containerTitleEl = document.getElementById('containerTitle');

        // --- Item & Crafting Definitions ---
        const items = {
            'Wood': { type: 'material' },
            'Stone': { type: 'material' },
            'Scrap Metal': { type: 'material' },
            'Nails': { type: 'material' },
            'Rope': { type: 'material' },
            'Tall Grass': { type: 'material' },
            'Raw Meat': { type: 'food', hunger: -15 },
            'Cooked Meat': { type: 'food', hunger: 25 },
            'Leather': { type: 'material' },
            'Animal Fat': { type: 'material' },
            'Dirty Water': { type: 'water', thirst: -10 },
            'Clean Water': { type: 'water', thirst: 30 },
            'Axe': { type: 'tool', harvest: ['Wood'], damage: 10 },
            'Pickaxe': { type: 'tool', harvest: ['Stone', 'Scrap Metal'], damage: 8 },
            'Knife': { type: 'tool', harvest: ['Animal'], damage: 15 },
            'Canteen': { type: 'container', capacity: 1, holds: null }, // holds: { name: 'Dirty Water', quantity: 1 }
            'Campfire': { type: 'placeable', cookTime: 30, fuel: 0 }, // Fuel could be wood
            'Crafting Table': { type: 'placeable', allows: ['advanced'] }, // Example category
            'Forge': { type: 'placeable', allows: ['metal'] } // Example category
        };

        const recipes = {
            'Axe': { requires: [{ name: 'Wood', quantity: 3 }, { name: 'Stone', quantity: 2 }], output: { name: 'Axe', quantity: 1 }, category: 'basic' },
            'Pickaxe': { requires: [{ name: 'Wood', quantity: 3 }, { name: 'Stone', quantity: 3 }], output: { name: 'Pickaxe', quantity: 1 }, category: 'basic' },
            'Rope': { requires: [{ name: 'Tall Grass', quantity: 5 }], output: { name: 'Rope', quantity: 1 }, category: 'basic' },
            'Campfire': { requires: [{ name: 'Wood', quantity: 5 }, { name: 'Stone', quantity: 8 }], output: { name: 'Campfire', quantity: 1 }, category: 'basic' },
            'Crafting Table': { requires: [{ name: 'Wood', quantity: 10 }, { name: 'Nails', quantity: 4 }], output: { name: 'Crafting Table', quantity: 1 }, category: 'basic' },
            'Forge': { requires: [{ name: 'Stone', quantity: 20 }, { name: 'Scrap Metal', quantity: 5 }], output: { name: 'Forge', quantity: 1 }, category: 'advanced' }, // Requires Crafting Table nearby? (Not implemented)
            // Add more recipes...
        };

        function hasResources(recipe) {
            for (const req of recipe.requires) {
                let found = getTotalResourceCount(req.name);
                if (found < req.quantity) return false;
            }
            return true;
        }

        function consumeResources(recipe) {
            for (const req of recipe.requires) {
                removeFromInventory(req.name, req.quantity);
            }
        }

        function craftItem(itemName) {
            const recipe = recipes[itemName];
            if (!recipe) return;

            // Check proximity to required workbench (Simplified - not implemented)
            // let canCraftHere = recipe.category === 'basic';
            // if (recipe.category === 'advanced') // Check if near crafting table
            // if (recipe.category === 'metal') // Check if near forge

            if (hasResources(recipe)) {
                consumeResources(recipe);
                addToInventory(recipe.output.name, recipe.output.quantity, true); // true = try quickbar first
                updateCraftingMenu(); // Update availability display
                updateInventoryUI();
                updateQuickBarUI();
                console.log(`Crafted ${itemName}`);
            } else {
                console.log(`Not enough resources to craft ${itemName}`);
            }
        }

        // --- Inventory Management ---
        function findInventoryStack(itemName) {
            return player.inventory.findIndex(slot => slot && slot.name === itemName);
        }
         function findQuickBarStack(itemName) {
            return player.quickBar.findIndex(slot => slot && slot.name === itemName);
        }

        function addToInventory(itemName, quantity = 1, tryQuickBarFirst = false) {
            const itemData = items[itemName];
            if (!itemData) return;

             if (tryQuickBarFirst) {
                // 1. Try stacking in quick bar
                let quickBarSlotIndex = findQuickBarStack(itemName);
                if (quickBarSlotIndex !== -1) {
                     player.quickBar[quickBarSlotIndex].quantity += quantity;
                     updateQuickBarUI();
                     return;
                 }
                // 2. Try empty slot in quick bar
                 let emptyQuickSlot = player.quickBar.findIndex(slot => slot === null);
                 if (emptyQuickSlot !== -1) {
                     player.quickBar[emptyQuickSlot] = { name: itemName, quantity: quantity };
                     updateQuickBarUI();
                     updateEquippedItemDisplay(); // Update if selected slot was empty
                     return;
                 }
            }

            // 3. Try stacking in main inventory
            let invSlotIndex = findInventoryStack(itemName);
            if (invSlotIndex !== -1) {
                player.inventory[invSlotIndex].quantity += quantity;
            } else {
            // 4. Add to new slot in main inventory
                 // Find first empty slot or add to end
                let emptyInvSlot = player.inventory.findIndex(slot => slot === null);
                if (emptyInvSlot !== -1) {
                    player.inventory[emptyInvSlot] = { name: itemName, quantity: quantity };
                } else {
                    player.inventory.push({ name: itemName, quantity: quantity });
                }
            }
            updateInventoryUI();
        }


        function removeFromInventory(itemName, quantity = 1) {
            let remaining = quantity;

            // Check quick bar first
            for (let i = 0; i < player.quickBar.length && remaining > 0; i++) {
                const slot = player.quickBar[i];
                if (slot && slot.name === itemName) {
                    const take = Math.min(remaining, slot.quantity);
                    slot.quantity -= take;
                    remaining -= take;
                    if (slot.quantity <= 0) {
                        player.quickBar[i] = null;
                         if (player.selectedQuickSlot === i) updateEquippedItemDisplay(); // Update if equipped item removed
                    }
                }
            }
            updateQuickBarUI();

            if (remaining <= 0) return true; // Done

            // Check main inventory
             for (let i = 0; i < player.inventory.length && remaining > 0; i++) {
                const slot = player.inventory[i];
                if (slot && slot.name === itemName) {
                    const take = Math.min(remaining, slot.quantity);
                    slot.quantity -= take;
                    remaining -= take;
                    if (slot.quantity <= 0) {
                         // Keep slot index but clear item, or remove entirely? Let's clear.
                        player.inventory[i] = null;
                        // Compact array (optional): player.inventory = player.inventory.filter(Boolean);
                    }
                }
            }
            updateInventoryUI(); // Update after potentially modifying inventory

            return remaining <= 0; // Return true if all quantity was removed
        }


         function getTotalResourceCount(itemName) {
            let count = 0;
            player.inventory.forEach(slot => {
                if (slot && slot.name === itemName) count += slot.quantity;
            });
            player.quickBar.forEach(slot => {
                if (slot && slot.name === itemName) count += slot.quantity;
            });
            return count;
        }

        function moveItem(source, sourceIndex, destination, destinationIndex) {
            // Simplified: Moves entire stack
            let itemToMove = null;

            if (source === 'inventory') {
                itemToMove = player.inventory[sourceIndex];
                player.inventory[sourceIndex] = null;
            } else if (source === 'quickBar') {
                itemToMove = player.quickBar[sourceIndex];
                player.quickBar[sourceIndex] = null;
            } else if (source === 'container') {
                itemToMove = player.interactingWith.inventory[sourceIndex];
                player.interactingWith.inventory[sourceIndex] = null;
            }

            if (!itemToMove) return; // Nothing to move

            if (destination === 'inventory') {
                // Try to stack first (simplified - just finds first compatible stack)
                let stackIndex = player.inventory.findIndex(slot => slot && slot.name === itemToMove.name);
                 if (stackIndex !== -1) {
                    player.inventory[stackIndex].quantity += itemToMove.quantity;
                } else {
                     // Place in specific slot if empty, otherwise find first empty, else add to end
                     if (destinationIndex !== undefined && !player.inventory[destinationIndex]) {
                         player.inventory[destinationIndex] = itemToMove;
                     } else {
                         let emptySlot = player.inventory.findIndex(slot => !slot);
                         if(emptySlot !== -1) player.inventory[emptySlot] = itemToMove;
                         else player.inventory.push(itemToMove); // Add to end if full
                     }
                }
            } else if (destination === 'quickBar') {
                // Try to stack
                 let stackIndex = player.quickBar.findIndex(slot => slot && slot.name === itemToMove.name);
                 if (stackIndex !== -1) {
                    player.quickBar[stackIndex].quantity += itemToMove.quantity;
                 } else {
                    // Place in specific slot if empty, otherwise don't move (quickbar is fixed size)
                    if (destinationIndex !== undefined && !player.quickBar[destinationIndex]) {
                         player.quickBar[destinationIndex] = itemToMove;
                    } else {
                         // Failed to move to quickbar, put it back where it came from
                         if (source === 'inventory') player.inventory[sourceIndex] = itemToMove;
                         else if (source === 'quickBar') player.quickBar[sourceIndex] = itemToMove; // Should not happen from QB to QB same slot
                         else if (source === 'container') player.interactingWith.inventory[sourceIndex] = itemToMove;
                         console.log("Quickbar slot occupied or invalid.");
                         return; // Abort moving back
                    }
                 }
            } else if (destination === 'container') {
                if (!player.interactingWith) return; // No container open

                 let stackIndex = player.interactingWith.inventory.findIndex(slot => slot && slot.name === itemToMove.name);
                 if (stackIndex !== -1) {
                     player.interactingWith.inventory[stackIndex].quantity += itemToMove.quantity;
                 } else {
                      if (destinationIndex !== undefined && !player.interactingWith.inventory[destinationIndex]) {
                         player.interactingWith.inventory[destinationIndex] = itemToMove;
                     } else {
                         let emptySlot = player.interactingWith.inventory.findIndex(slot => !slot);
                         if(emptySlot !== -1) player.interactingWith.inventory[emptySlot] = itemToMove;
                         else player.interactingWith.inventory.push(itemToMove); // Add to end if full
                     }
                 }
                 updateContainerUI(); // Update container view immediately
            }


            // Update UI
            updateInventoryUI();
            updateQuickBarUI();
            updateEquippedItemDisplay();
        }

        // --- UI Update Functions ---
        function updateHUD() {
            healthEl.textContent = player.health.toFixed(0);
            hungerEl.textContent = player.hunger.toFixed(0);
            thirstEl.textContent = player.thirst.toFixed(0);
        }

        function updateEquippedItemDisplay() {
            const item = player.quickBar[player.selectedQuickSlot];
            equippedItemEl.textContent = item ? `${item.name} (${item.quantity})` : 'None';
        }

        function updateQuickBarUI() {
            quickBarEl.innerHTML = '';
            for (let i = 0; i < player.quickBar.length; i++) {
                const slot = player.quickBar[i];
                const slotEl = document.createElement('div');
                slotEl.classList.add('quickSlot');
                if (i === player.selectedQuickSlot) {
                    slotEl.classList.add('selected');
                }
                if (slot) {
                    slotEl.textContent = `${slot.name.substring(0,6)}...`; // Abbreviate
                     const countEl = document.createElement('div');
                    countEl.classList.add('item-count');
                    countEl.textContent = slot.quantity;
                    slotEl.appendChild(countEl);
                } else {
                     slotEl.innerHTML = `[${i+1}]`; // Show number binding
                }
                 slotEl.dataset.index = i;
                slotEl.addEventListener('click', () => { // Allow clicking quickbar slots too
                    player.selectedQuickSlot = i;
                    updateQuickBarUI();
                    updateEquippedItemDisplay();
                });
                 // Add drag/drop or shift-click handlers if needed
                 slotEl.addEventListener('click', (event) => {
                    if (event.shiftKey) {
                         moveItem('quickBar', i, 'inventory');
                    } else {
                         player.selectedQuickSlot = i;
                         updateQuickBarUI();
                         updateEquippedItemDisplay();
                     }
                });

                quickBarEl.appendChild(slotEl);
            }
        }


        function updateInventoryUI() {
            inventoryGridEl.innerHTML = '';
             // Determine grid size dynamically or use fixed size
             const invSize = Math.max(25, player.inventory.length); // Min 5x5 grid
            for (let i = 0; i < invSize; i++) {
                const item = player.inventory[i];
                const slotEl = document.createElement('div');
                slotEl.classList.add('inventorySlot');
                if (item) {
                    slotEl.textContent = `${item.name.substring(0,6)}...`;
                    const countEl = document.createElement('div');
                    countEl.classList.add('item-count');
                    countEl.textContent = item.quantity;
                    slotEl.appendChild(countEl);
                }
                slotEl.dataset.index = i;
                 slotEl.addEventListener('click', (event) => {
                    if (event.shiftKey) {
                        moveItem('inventory', i, 'quickBar');
                    }
                 });
                inventoryGridEl.appendChild(slotEl);
            }
        }

        function updateCraftingMenu() {
            craftingListEl.innerHTML = '';
            for (const itemName in recipes) {
                const recipe = recipes[itemName];
                const itemEl = document.createElement('div');
                itemEl.classList.add('craftingItem');
                itemEl.textContent = `${itemName} (Req: ${recipe.requires.map(r => `${r.quantity} ${r.name}`).join(', ')})`;
                if (hasResources(recipe)) {
                    itemEl.classList.add('canCraft');
                }
                itemEl.onclick = () => craftItem(itemName);
                craftingListEl.appendChild(itemEl);
            }
        }

        function updateContainerUI() {
            if (!player.isContainerOpen || !player.interactingWith) return;

            containerTitleEl.textContent = player.interactingWith.name || "Container"; // Use container's name if it has one
            containerGridEl.innerHTML = '';
            const containerInv = player.interactingWith.inventory;
            const containerSize = Math.max(10, containerInv.length); // Example size

            for (let i = 0; i < containerSize; i++) {
                const item = containerInv[i];
                const slotEl = document.createElement('div');
                slotEl.classList.add('containerSlot');
                 if (item) {
                    slotEl.textContent = `${item.name.substring(0,6)}...`;
                    const countEl = document.createElement('div');
                    countEl.classList.add('item-count');
                    countEl.textContent = item.quantity;
                    slotEl.appendChild(countEl);
                }
                slotEl.dataset.index = i;
                 slotEl.addEventListener('click', (event) => {
                     // SHIFT + Click moves item from container to player inventory
                    if (event.shiftKey) {
                        moveItem('container', i, 'inventory');
                    }
                 });
                containerGridEl.appendChild(slotEl);
            }
        }


        function toggleInventory() {
            player.isInventoryOpen = !player.isInventoryOpen;
            inventoryEl.style.display = player.isInventoryOpen ? 'block' : 'none';
            if (player.isInventoryOpen) {
                updateInventoryUI();
                 if (controls.isLocked) controls.unlock(); // Unlock mouse when inventory opens
            } else {
                if (!player.isCraftingOpen && !player.isContainerOpen) controls.lock(); // Lock mouse only if other menus aren't open
            }
        }

        function toggleCraftingMenu() {
            player.isCraftingOpen = !player.isCraftingOpen;
            craftingMenuEl.style.display = player.isCraftingOpen ? 'block' : 'none';
            if (player.isCraftingOpen) {
                updateCraftingMenu();
                 if (controls.isLocked) controls.unlock();
            } else {
                 if (!player.isInventoryOpen && !player.isContainerOpen) controls.lock();
            }
        }

         function toggleContainerView(container = null) {
             if (container) { // Opening
                 player.interactingWith = container;
                 player.isContainerOpen = true;
                 updateContainerUI();
                 containerViewEl.style.display = 'block';
                 if (controls.isLocked) controls.unlock();
             } else { // Closing
                 player.isContainerOpen = false;
                 containerViewEl.style.display = 'none';
                 player.interactingWith = null;
                 if (!player.isInventoryOpen && !player.isCraftingOpen) {
                     controls.lock();
                 }
             }
         }


        // --- World Generation ---
        function createWorldObject(geometry, material, position, options = {}) {
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = {
                type: options.type || 'static', // 'static', 'tree', 'rock', 'animal', 'barrel', 'crate', 'building', 'grass'
                health: options.health || 100,
                resource: options.resource || null, // e.g., 'Wood', 'Stone'
                resourceAmount: options.resourceAmount || 0,
                inventory: options.inventory || null, // For containers
                name: options.name || '', // For containers
                isCollidable: options.isCollidable !== undefined ? options.isCollidable : true,
                // Animal specific
                aiState: 'idle',
                moveTarget: null,
                speed: options.speed || 1,
            };

            scene.add(mesh);

            if (mesh.userData.isCollidable) {
                objects.push(mesh); // Add to general collision list
            }

            if (['tree', 'rock', 'grass'].includes(mesh.userData.type)) {
                resources.push(mesh);
            } else if (mesh.userData.type === 'animal') {
                animals.push(mesh);
            } else if (['barrel', 'crate'].includes(mesh.userData.type)) {
                containers.push(mesh);
                // Initialize inventory if not provided
                if (!mesh.userData.inventory) {
                     mesh.userData.inventory = generateLoot(mesh.userData.type);
                }
            } else if (['campfire', 'workbench', 'forge'].includes(mesh.userData.type)) {
                placeables.push(mesh);
            }

            return mesh;
        }

        function generateLoot(containerType) {
             // Simple loot table - customize as needed
             const loot = [];
             const numItems = Math.floor(Math.random() * 4) + 1; // 1-4 items

             for (let i = 0; i < numItems; i++) {
                 const rand = Math.random();
                 let item = null;
                 if (containerType === 'barrel') {
                     if (rand < 0.4) item = { name: 'Scrap Metal', quantity: Math.floor(Math.random() * 5) + 1 };
                     else if (rand < 0.7) item = { name: 'Nails', quantity: Math.floor(Math.random() * 10) + 2 };
                     else if (rand < 0.9) item = { name: 'Dirty Water', quantity: 1}; // Represented by filling a canteen later
                     else item = { name: 'Animal Fat', quantity: Math.floor(Math.random() * 2) + 1 };
                 } else { // Crate (better loot?)
                     if (rand < 0.3) item = { name: 'Cooked Meat', quantity: Math.floor(Math.random() * 2) + 1 };
                     else if (rand < 0.6) item = { name: 'Rope', quantity: 1 };
                     else if (rand < 0.8) item = { name: 'Clean Water', quantity: 1 };
                     else item = { name: 'Leather', quantity: Math.floor(Math.random() * 3) + 1 };
                 }
                  if (item) {
                     // Try to stack if already present in this container's loot list
                      let existing = loot.find(l => l && l.name === item.name);
                      if (existing) existing.quantity += item.quantity;
                      else loot.push(item); // Add as new item
                  }
             }
             // Fill remaining slots with null up to a certain size if needed for UI consistency
             // while(loot.length < 10) loot.push(null);
             return loot;
         }

        function initScene(settings) {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 150);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = settings.playerHeight; // Set initial height based on settings
            player.height = settings.playerHeight;
            player.speed = settings.playerSpeed;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); // Add camera group to scene

             // Event listener to lock pointer on click
             document.body.addEventListener('click', () => {
                 if (!player.isInventoryOpen && !player.isCraftingOpen && !player.isContainerOpen) {
                     controls.lock();
                 }
             }, false);

             controls.addEventListener('lock', () => {
                 console.log("Pointer Locked");
                 // Hide menus if they were somehow left open
                 inventoryEl.style.display = 'none';
                 craftingMenuEl.style.display = 'none';
                 containerViewEl.style.display = 'none';
                 player.isInventoryOpen = false;
                 player.isCraftingOpen = false;
                 player.isContainerOpen = false;
                 player.interactingWith = null;
             });

             controls.addEventListener('unlock', () => {
                 console.log("Pointer Unlocked");
                  // Don't automatically show menus, player uses keys (TAB/C)
             });


            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 25);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
             directionalLight.shadow.camera.left = -100;
             directionalLight.shadow.camera.right = 100;
             directionalLight.shadow.camera.top = 100;
             directionalLight.shadow.camera.bottom = -100;
             directionalLight.shadow.camera.near = 0.5;
             directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);
            scene.add(directionalLight.target);


            // Ground
            const groundGeometry = new THREE.PlaneGeometry(300, 300);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 1, metalness: 0 }); // DarkGreen-ish
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.userData = { type: 'ground', isCollidable: false }; // Ground itself isn't usually in the 'objects' array for player collision
            scene.add(ground);

            // Water plane (simple visual)
            const waterGeometry = new THREE.PlaneGeometry(80, 80);
            const waterMaterial = new THREE.MeshStandardMaterial({ color: 0x3366CC, transparent: true, opacity: 0.7, roughness: 0.2, metalness: 0.1 });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.set(60, 0.1, 60); // Place it somewhere
            water.receiveShadow = true; // Water can receive shadows
            water.userData = { type: 'water', isCollidable: false };
            scene.add(water);

             // --- Populate World ---
             const worldSize = 100; // Radius from center
             const numTrees = 50;
             const numRocks = 30;
             const numGrass = 80;
             const numScrap = 15;
             const numBarrels = 10;
             const numBuildings = 3;
             const numAnimals = 5;

             const treeGeo = new THREE.BoxGeometry(1, 6, 1);
             const treeMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown trunk
             const leavesGeo = new THREE.SphereGeometry(2.5, 8, 6);
             const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // ForestGreen leaves

             for (let i = 0; i < numTrees; i++) {
                 const x = (Math.random() - 0.5) * worldSize * 1.8;
                 const z = (Math.random() - 0.5) * worldSize * 1.8;
                 // Basic check to avoid spawning directly in water area (adjust coords if water moves)
                 if (x > 20 && x < 100 && z > 20 && z < 100) continue;

                 const trunk = createWorldObject(treeGeo, treeMat, new THREE.Vector3(x, 3, z), {
                     type: 'tree', resource: 'Wood', resourceAmount: 5, health: 100, isCollidable: true
                 });
                 const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                 leaves.position.set(x, 6.5, z);
                 leaves.castShadow = true;
                 leaves.userData.isCollidable = false; // Leaves usually aren't solid
                 scene.add(leaves);
                 trunk.userData.leaves = leaves; // Link leaves for removal
             }

             const rockGeo = new THREE.DodecahedronGeometry(1.5, 0); // Polyhedron looks rock-ish
             const rockMat = new THREE.MeshStandardMaterial({ color: 0x808080 }); // Grey

             for (let i = 0; i < numRocks; i++) {
                 const x = (Math.random() - 0.5) * worldSize * 1.8;
                 const z = (Math.random() - 0.5) * worldSize * 1.8;
                  if (x > 20 && x < 100 && z > 20 && z < 100) continue;
                 createWorldObject(rockGeo, rockMat, new THREE.Vector3(x, 0.75, z), {
                     type: 'rock', resource: 'Stone', resourceAmount: 3, health: 150, isCollidable: true
                 });
             }

             const grassGeo = new THREE.PlaneGeometry(1, 1);
             const grassMat = new THREE.MeshBasicMaterial({ color: 0x90EE90, side: THREE.DoubleSide, transparent: true, opacity: 0.8 }); // LightGreen, basic for performance
             for (let i = 0; i < numGrass; i++) {
                 const x = (Math.random() - 0.5) * worldSize * 1.8;
                 const z = (Math.random() - 0.5) * worldSize * 1.8;
                 if (x > 20 && x < 100 && z > 20 && z < 100) continue;
                 const grassPatch = createWorldObject(grassGeo, grassMat, new THREE.Vector3(x, 0.5, z), {
                    type: 'grass', resource: 'Tall Grass', resourceAmount: 1, health: 10, isCollidable: false // Grass not collidable
                 });
                 grassPatch.rotation.x = -Math.PI / 2; // Lay flat initially (doesn't look great, needs better geometry)
                 // Maybe add more planes rotated for a "bush" effect? Simple plane for now.
             }

              const scrapGeo = new THREE.BoxGeometry(0.5, 0.1, 0.8);
              const scrapMat = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, roughness: 0.6, metalness: 0.8 }); // Rusty metal color
              for (let i = 0; i < numScrap; i++) {
                  const x = (Math.random() - 0.5) * worldSize * 1.6; // Slightly closer to center?
                  const z = (Math.random() - 0.5) * worldSize * 1.6;
                  if (x > 20 && x < 100 && z > 20 && z < 100) continue;
                  createWorldObject(scrapGeo, scrapMat, new THREE.Vector3(x, 0.05, z), {
                      type: 'scrap', resource: 'Scrap Metal', resourceAmount: 1, health: 10, isCollidable: false // Small item, not collidable by player
                  });
              }

              const barrelGeo = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 16);
              const barrelMat = new THREE.MeshStandardMaterial({ color: 0xD2691E }); // Chocolate/Brown
              for (let i = 0; i < numBarrels; i++) {
                  const x = (Math.random() - 0.5) * worldSize * 1.5;
                  const z = (Math.random() - 0.5) * worldSize * 1.5;
                  createWorldObject(barrelGeo, barrelMat, new THREE.Vector3(x, 0.75, z), {
                       type: 'barrel', isCollidable: true, name: 'Barrel' // Loot generated automatically
                  });
              }

              // Buildings (Simple Hollow Box)
              const buildingWallGeo = new THREE.BoxGeometry(10, 5, 0.5);
              const buildingWallMat = new THREE.MeshStandardMaterial({ color: 0xAAAAAA }); // Concrete-ish
              const buildingFloorGeo = new THREE.BoxGeometry(10.5, 0.2, 10.5);
              const buildingFloorMat = new THREE.MeshStandardMaterial({ color: 0x777777 });
              const crateGeo = new THREE.BoxGeometry(1, 1, 1);
              const crateMat = new THREE.MeshStandardMaterial({ color: 0xDEB887 }); // BurlyWood

              for (let i = 0; i < numBuildings; i++) {
                 const baseX = (Math.random() - 0.5) * worldSize * 1.2;
                 const baseZ = (Math.random() - 0.5) * worldSize * 1.2;

                 // Floor
                 createWorldObject(buildingFloorGeo, buildingFloorMat, new THREE.Vector3(baseX, 0.1, baseZ), { type: 'building_part', isCollidable: true });

                 // Walls (with a doorway gap on one side)
                 // Back Wall
                  createWorldObject(buildingWallGeo, buildingWallMat, new THREE.Vector3(baseX, 2.5, baseZ - 5), { type: 'building_part', isCollidable: true });
                 // Left Wall
                  let wallL = createWorldObject(buildingWallGeo, buildingWallMat, new THREE.Vector3(baseX - 5, 2.5, baseZ), { type: 'building_part', isCollidable: true });
                  wallL.rotation.y = Math.PI / 2;
                 // Right Wall
                  let wallR = createWorldObject(buildingWallGeo, buildingWallMat, new THREE.Vector3(baseX + 5, 2.5, baseZ), { type: 'building_part', isCollidable: true });
                  wallR.rotation.y = Math.PI / 2;
                 // Front Wall (Two parts for doorway)
                  const doorWidth = 2;
                  const frontWallPartGeo = new THREE.BoxGeometry( (10 - doorWidth)/2 , 5, 0.5);
                  let wallF1 = createWorldObject(frontWallPartGeo, buildingWallMat, new THREE.Vector3(baseX - (10+doorWidth)/4 , 2.5, baseZ + 5), { type: 'building_part', isCollidable: true });
                  let wallF2 = createWorldObject(frontWallPartGeo, buildingWallMat, new THREE.Vector3(baseX + (10+doorWidth)/4 , 2.5, baseZ + 5), { type: 'building_part', isCollidable: true });

                 // Add some crates inside
                 const numCrates = Math.floor(Math.random() * 3) + 1; // 1-3 crates
                 for (let j=0; j<numCrates; ++j) {
                     const crateX = baseX + (Math.random() - 0.5) * 8; // Inside building bounds
                     const crateZ = baseZ + (Math.random() - 0.5) * 8;
                     createWorldObject(crateGeo, crateMat, new THREE.Vector3(crateX, 0.6, crateZ), {
                        type: 'crate', isCollidable: true, name: 'Crate' // Loot generated automatically
                     });
                 }
              }

              // Animals (Simple spheres for now)
              const animalGeo = new THREE.SphereGeometry(0.7, 16, 8);
              const animalMat = new THREE.MeshStandardMaterial({ color: 0x964B00 }); // Brownish
              for (let i = 0; i < numAnimals; i++) {
                  const x = (Math.random() - 0.5) * worldSize * 1.7;
                  const z = (Math.random() - 0.5) * worldSize * 1.7;
                   if (x > 20 && x < 100 && z > 20 && z < 100) continue; // Avoid water
                   createWorldObject(animalGeo, animalMat, new THREE.Vector3(x, 0.7, z), {
                       type: 'animal', health: 50, isCollidable: true, speed: 1.5 + Math.random() // Give variable speed
                   });
               }

             // Starting Inventory based on settings
             addToInventory('Wood', settings.startResources);
             addToInventory('Stone', settings.startResources);
             addToInventory('Axe', 1, true); // Start with tools in quickbar
             addToInventory('Pickaxe', 1, true);
             addToInventory('Knife', 1, true);
             addToInventory('Canteen', 1, true);

             // Setup UI
             updateInventoryUI();
             updateQuickBarUI();
             updateEquippedItemDisplay();
             updateCraftingMenu(); // Initial craft check
             updateHUD();

             // Add Listeners
             window.addEventListener('resize', onWindowResize, false);
             document.addEventListener('keydown', onKeyDown, false);
             document.addEventListener('keyup', onKeyUp, false);
             document.addEventListener('mousedown', onMouseDown, false);

             animate(); // Start game loop
        }


        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            // Allow text input in settings menu even if pointer lock might be active
            if (document.activeElement.tagName === 'INPUT') return;

            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward.value = true; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft.value = true; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward.value = true; break;
                case 'ArrowRight':
                case 'KeyD': moveRight.value = true; break;
                case 'Space': jump.value = true; break;
                case 'Tab':
                    event.preventDefault(); // Prevent tabbing out of window
                     if (player.isContainerOpen) {
                         toggleContainerView(); // Close container first if open
                     } else {
                         toggleInventory();
                         if (player.isCraftingOpen) toggleCraftingMenu(); // Close crafting if opening inv
                     }
                    break;
                case 'KeyC':
                     if (player.isContainerOpen) {
                         toggleContainerView(); // Close container first if open
                     } else {
                        toggleCraftingMenu();
                        if (player.isInventoryOpen) toggleInventory(); // Close inventory if opening crafting
                     }
                    break;
                case 'KeyE': // Interaction key
                    handleInteraction();
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                     // Used in combination with clicks, handled in UI element listeners
                    break;
                 // Quick slot selection
                 case 'Digit1': selectQuickSlot(0); break;
                 case 'Digit2': selectQuickSlot(1); break;
                 case 'Digit3': selectQuickSlot(2); break;
                 case 'Digit4': selectQuickSlot(3); break;
                 case 'Digit5': selectQuickSlot(4); break;
                 // Add more digits if quickbar is larger
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward.value = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft.value = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward.value = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight.value = false; break;
                case 'Space': jump.value = false; break; // Reset jump flag
            }
        }

         function onMouseDown(event) {
             // Only handle clicks if pointer is locked (i.e., playing, not in menu)
             if (!controls.isLocked) return;

             if (event.button === 0) { // Left mouse button
                 handlePrimaryAction();
             } else if (event.button === 2) { // Right mouse button
                 handleSecondaryAction();
             }
         }

        function selectQuickSlot(index) {
             if (index >= 0 && index < player.quickBar.length) {
                 player.selectedQuickSlot = index;
                 updateQuickBarUI();
                 updateEquippedItemDisplay();
             }
         }

        // --- Core Actions ---
        function handleInteraction() {
            const lookingAt = getObjectPlayerIsLookingAt();
             if (lookingAt && lookingAt.distance < interactionDistance) {
                 const obj = lookingAt.object;
                 const data = obj.userData;

                 if (data.type === 'barrel' || data.type === 'crate') {
                     toggleContainerView(obj); // Open the container UI
                 } else if (data.type === 'grass') {
                     // Direct harvest for simple things
                     harvestResource(obj);
                 } else if (data.type === 'scrap') {
                     // Direct pickup for small items
                     if (addToInventory(data.resource, data.resourceAmount)) {
                         scene.remove(obj);
                         // Remove from relevant arrays (optional, depends if searching them)
                         const index = resources.indexOf(obj); if(index > -1) resources.splice(index, 1);
                     }
                 }
                 // Add interactions for campfire (add fuel/cook), water source (fill canteen), workbench, forge etc.
                 // Example: Fill canteen
                 else if (data.type === 'water') {
                      let canteenSlot = player.quickBar.find(s => s && s.name === 'Canteen' && (!s.holds || s.holds.quantity === 0));
                      if (!canteenSlot) canteenSlot = player.inventory.find(s => s && s.name === 'Canteen' && (!s.holds || s.holds.quantity === 0));

                      if(canteenSlot) {
                          canteenSlot.holds = { name: 'Dirty Water', quantity: 1 };
                          console.log("Filled Canteen with Dirty Water");
                          updateInventoryUI(); // Update in case it was in main inv
                          updateQuickBarUI(); // Update in case it was in quickbar
                      } else {
                          console.log("No empty Canteen found.");
                      }
                 }

             } else if (player.isContainerOpen) {
                 // If E is pressed while container is open, close it
                 toggleContainerView();
             }
        }

        function handlePrimaryAction() { // Left Click
            const equipped = player.quickBar[player.selectedQuickSlot];
            const lookingAt = getObjectPlayerIsLookingAt();

            if (lookingAt && lookingAt.distance < interactionDistance) {
                 const targetObj = lookingAt.object;
                 const targetData = targetObj.userData;

                 if (equipped && items[equipped.name]?.type === 'tool') {
                     const toolData = items[equipped.name];

                     // Harvesting Resources
                     if (toolData.harvest && toolData.harvest.includes(targetData.resource)) {
                         harvestResource(targetObj, toolData.damage);
                     }
                     // Hunting Animals
                     else if (targetData.type === 'animal' && toolData.harvest && toolData.harvest.includes('Animal')) {
                          damageAnimal(targetObj, toolData.damage);
                     }
                     // Add attacking other things if needed

                 } else if (equipped && items[equipped.name]?.type === 'placeable') {
                     // Placement logic (simplified - places in front of player)
                     placeItem(equipped.name, lookingAt.point);

                 } else {
                     // Punching? Default interaction?
                      console.log("Punching doesn't do much yet.");
                      if(targetData.type === 'animal') damageAnimal(targetObj, 2); // Low punch damage
                 }

            } else if (equipped && items[equipped.name]?.type === 'placeable') {
                 // Place item if looking at ground far away (within reason)
                 const groundIntersect = getGroundIntersect();
                 if (groundIntersect && groundIntersect.distance < 5) { // Placement range
                    placeItem(equipped.name, groundIntersect.point);
                 }
            } else if (equipped && items[equipped.name]?.type === 'food') {
                 eatFood(equipped.name);
            } else if (equipped && items[equipped.name]?.type === 'water') {
                 drinkWater(equipped.name);
            }
             // Add other primary actions (shooting, etc.)
        }

        function handleSecondaryAction() { // Right Click
            const equipped = player.quickBar[player.selectedQuickSlot];
            // Example: Aiming (not implemented), block, alt-fire, use canteen
             if (equipped && equipped.name === 'Canteen' && equipped.holds && equipped.holds.quantity > 0) {
                 drinkWater(equipped.holds.name, true); // true = drink from canteen
             }
            // Add other secondary actions
            console.log("Right click action");
        }

        function placeItem(itemName, position) {
            const itemData = items[itemName];
            if (!itemData || itemData.type !== 'placeable') return;

            // Simple placement - check if position is reasonably clear (not inside another object)
             let clear = true;
             const placeRadius = 1.0; // How close other objects can be
             for (const obj of objects.concat(resources).concat(placeables)) {
                 if (obj.position.distanceTo(position) < placeRadius) {
                     clear = false;
                     console.log("Placement blocked.");
                     break;
                 }
             }

             if(clear) {
                 let geometry, material;
                 // Define geometry/material based on item name
                 if (itemName === 'Campfire') {
                     geometry = new THREE.CylinderGeometry(0.8, 1.2, 0.5, 12);
                     material = new THREE.MeshStandardMaterial({ color: 0x555555 }); // Dark grey base
                     // Could add fake logs/flames later
                 } else if (itemName === 'Crafting Table') {
                     geometry = new THREE.BoxGeometry(2, 1, 1.5);
                     material = new THREE.MeshStandardMaterial({ color: 0xAC8560 }); // Wood color
                 } else if (itemName === 'Forge') {
                     geometry = new THREE.BoxGeometry(1.5, 1.8, 1.5);
                     material = new THREE.MeshStandardMaterial({ color: 0x666666 }); // Stone color
                 } else {
                     return; // Unknown placeable item
                 }

                 const newObj = createWorldObject(geometry, material, position.setY(geometry.parameters.height / 2 || 0.5), { // Adjust Y based on geo height
                     type: itemName.toLowerCase(), // e.g., 'campfire'
                     isCollidable: true,
                     // Add specific properties like fuel for campfire if needed
                     fuel: itemName === 'Campfire' ? 0 : undefined,
                     cookingSlots: itemName === 'Campfire' ? [null, null] : undefined, // Example: 2 cooking slots
                     cookingTimers: itemName === 'Campfire' ? [0, 0] : undefined
                 });

                 // Consume the item from inventory/quickbar
                 if (removeFromInventory(itemName, 1)) {
                     console.log(`Placed ${itemName}`);
                     placeables.push(newObj); // Add to placeables array
                     if(newObj.userData.isCollidable) objects.push(newObj); // Add to collidables if needed
                 } else {
                      // Should not happen if we checked inventory before calling place
                     scene.remove(newObj); // Remove the preview/object if consumption failed
                     console.error("Failed to consume placed item from inventory!");
                 }
             }
        }


        function harvestResource(resourceNode, damage = 10) {
             const data = resourceNode.userData;
             if (!data || !data.resource || data.health <= 0) return; // Not harvestable or already depleted

             data.health -= damage; // Damage based on tool/action
             console.log(`${data.type} health: ${data.health}`);

             // Simple feedback (e.g., slight scale change)
             resourceNode.scale.y = 1 + (100 - data.health) / 500; // Shrink slightly as health lowers

             if (data.health <= 0) {
                 console.log(`Harvested ${data.resourceAmount} ${data.resource}`);
                 addToInventory(data.resource, data.resourceAmount);
                 scene.remove(resourceNode);
                 if (data.leaves) scene.remove(data.leaves); // Remove associated leaves if tree

                 // Remove from arrays
                 const idx = resources.indexOf(resourceNode); if (idx > -1) resources.splice(idx, 1);
                 const objIdx = objects.indexOf(resourceNode); if (objIdx > -1) objects.splice(objIdx, 1);
             }
        }

        function damageAnimal(animalMesh, damage) {
            const data = animalMesh.userData;
            if (!data || data.health <= 0) return;

            data.health -= damage;
            console.log(`Animal health: ${data.health}`);
            // Add visual feedback? Color flash?
             animalMesh.material.color.setHex(0xff0000); // Flash red briefly
             setTimeout(() => {
                if(animalMesh.material) animalMesh.material.color.setHex(0x964B00); // Reset color
             }, 150);


            if (data.health <= 0) {
                console.log("Animal hunted!");
                // Drop loot near animal position
                const dropPos = animalMesh.position.clone().add(new THREE.Vector3(0, 0.2, 0)); // Slightly above ground
                dropLoot(dropPos, [{ name: 'Raw Meat', quantity: Math.floor(Math.random()*3)+1 },
                                   { name: 'Leather', quantity: Math.floor(Math.random()*2)+1 },
                                   { name: 'Animal Fat', quantity: Math.floor(Math.random()*2)+1 }]);

                scene.remove(animalMesh);
                // Remove from arrays
                const idx = animals.indexOf(animalMesh); if (idx > -1) animals.splice(idx, 1);
                const objIdx = objects.indexOf(animalMesh); if (objIdx > -1) objects.splice(objIdx, 1);
            } else {
                // Make animal flee? (Simple version: set target away from player)
                 const fleeDir = animalMesh.position.clone().sub(camera.position).normalize();
                 data.moveTarget = animalMesh.position.clone().addScaledVector(fleeDir, 15); // Flee 15 units
                 data.aiState = 'fleeing';
            }
        }

        function dropLoot(position, lootTable) {
            // Create small visual representations of the loot on the ground
            // For simplicity, we'll just add the items directly to inventory if the player is close enough
            // Or create simple meshes that can be picked up via interaction [E]

             console.log("Loot dropped at", position);
             lootTable.forEach(item => {
                 if (item && item.quantity > 0) {
                    // Simplification: Just log it. A real game would spawn pickup items.
                    console.log(` - ${item.quantity}x ${item.name}`);
                    // To spawn pickup items: create small meshes at 'position', add userData { type: 'pickup', itemName: item.name, quantity: item.quantity }
                    // Add interaction logic to pick them up.
                     // Let's try spawning simple pickup markers
                     const pickupGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                     // Use different colors based on item type?
                     let color = 0xffffff;
                     if(items[item.name]?.type === 'food') color = 0xff8c00; // DarkOrange
                     if(items[item.name]?.type === 'material') color = 0xadd8e6; // LightBlue
                     const pickupMat = new THREE.MeshBasicMaterial({ color: color });
                     const pickupMesh = new THREE.Mesh(pickupGeo, pickupMat);
                     pickupMesh.position.copy(position).add(new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5)); // Slightly randomize drop pos
                     pickupMesh.userData = { type: 'pickup', name: item.name, quantity: item.quantity, isCollidable: false };
                     scene.add(pickupMesh);
                     // Need to add 'pickup' type to interaction logic [E]
                      resources.push(pickupMesh); // Add to a list that interaction checks
                 }
             });
        }

        function eatFood(foodName) {
            const foodData = items[foodName];
            if (!foodData || foodData.type !== 'food') return;

             if (removeFromInventory(foodName, 1)) {
                 player.hunger = Math.min(100, player.hunger + foodData.hunger);
                 // Add health effects if any
                 console.log(`Ate ${foodName}. Hunger: ${player.hunger}`);
                 updateHUD();
             } else {
                 console.log(`No ${foodName} to eat.`);
             }
        }

        function drinkWater(waterName, fromCanteen = false) {
             const waterData = items[waterName];
             if (!waterData || waterData.type !== 'water') return;

             if (fromCanteen) {
                 // Find the canteen that holds this water
                 let canteen = player.quickBar.find(s => s && s.name === 'Canteen' && s.holds?.name === waterName);
                 if (!canteen) canteen = player.inventory.find(s => s && s.name === 'Canteen' && s.holds?.name === waterName);

                 if (canteen && canteen.holds.quantity > 0) {
                     canteen.holds.quantity--;
                     if (canteen.holds.quantity <= 0) {
                         canteen.holds = null; // Empty the canteen
                     }
                     player.thirst = Math.min(100, player.thirst + waterData.thirst);
                     // Add health effects if dirty water
                     if (waterName === 'Dirty Water') player.health = Math.max(0, player.health - 10);
                     console.log(`Drank ${waterName} from Canteen. Thirst: ${player.thirst}`);
                     updateHUD();
                     updateInventoryUI();
                     updateQuickBarUI();
                 } else {
                     console.log(`Canteen with ${waterName} not found or is empty.`);
                 }

             } else {
                 // Drinking loose water item (if that's possible in your game)
                 if (removeFromInventory(waterName, 1)) {
                     player.thirst = Math.min(100, player.thirst + waterData.thirst);
                      if (waterName === 'Dirty Water') player.health = Math.max(0, player.health - 10);
                     console.log(`Drank ${waterName}. Thirst: ${player.thirst}`);
                     updateHUD();
                 } else {
                     console.log(`No ${waterName} item to drink.`);
                 }
             }
         }

         function processCampfire(campfire, delta) {
             const data = campfire.userData;
             if (!data || data.type !== 'campfire') return;

             // Cooking Logic (Simplified)
             for (let i = 0; i < data.cookingSlots.length; i++) {
                 if (data.cookingSlots[i] && data.cookingSlots[i].name === 'Raw Meat') {
                     // Requires fuel? (Simplification: assume infinite fuel for now)
                     data.cookingTimers[i] += delta;
                     if (data.cookingTimers[i] >= items['Campfire'].cookTime) {
                         console.log("Meat cooked!");
                         data.cookingSlots[i] = { name: 'Cooked Meat', quantity: 1 }; // Replace raw with cooked
                         data.cookingTimers[i] = 0; // Reset timer
                         // Add visual cue? Change fire color/intensity?
                     }
                 }
                  // Water Boiling Logic
                 else if (data.cookingSlots[i] && data.cookingSlots[i].name === 'Canteen' && data.cookingSlots[i].holds?.name === 'Dirty Water') {
                     data.cookingTimers[i] += delta;
                      const boilTime = 20; // Shorter time for water?
                     if (data.cookingTimers[i] >= boilTime) {
                          console.log("Water boiled!");
                          data.cookingSlots[i].holds.name = 'Clean Water'; // Change water type
                          data.cookingTimers[i] = 0;
                     }
                 } else {
                      // Reset timer if slot is empty or has non-cookable item
                      data.cookingTimers[i] = 0;
                 }
             }

             // Add interaction logic ([E]) to add/remove items from cookingSlots
             // This would likely open a small UI or use direct interaction prompts
         }


        // --- Update & Game Loop ---
        function updatePlayer(delta) {
            if (!controls.isLocked) return; // Don't move if menu is open/mouse unlocked

            const speed = player.speed * delta;
            const prevPosition = controls.getObject().position.clone(); // Store position before movement

            player.velocity.x = 0;
            player.velocity.z = 0;
            // player.velocity.y -= 9.8 * delta * 1.5; // Gravity (Simple - adjust multiplier) - Handled below more carefully

             // Get movement direction based on camera orientation
             const forward = new THREE.Vector3();
             const right = new THREE.Vector3();
             controls.getDirection(forward); // forward is a unit vector
             right.crossVectors(controls.getObject().up, forward).normalize(); // Get right vector

             if (moveForward.value) player.velocity.add(forward);
             if (moveBackward.value) player.velocity.sub(forward);
             if (moveLeft.value) player.velocity.add(right); // Moving left means adding the 'right' vector negatively in world space, but PointerLockControls handles it relative to view. We add here.
             if (moveRight.value) player.velocity.sub(right); // Subtract right vector to move right relative to view.

             // Normalize diagonal movement
             if(player.velocity.x !== 0 && player.velocity.z !== 0) {
                 player.velocity.normalize();
             }


             // Apply movement speed
             controls.moveForward(player.velocity.z * speed); // moveForward is relative to camera Z
             controls.moveRight(-player.velocity.x * speed); // moveRight is relative to camera X (invert velocity.x for correct direction relative to view)


             // --- Rudimentary Collision Detection ---
             const playerPos = controls.getObject().position;
             let collisionDetected = false;
             const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(playerPos.x, playerPos.y - player.height / 2 + 0.5, playerPos.z), // Center slightly below camera
                new THREE.Vector3(0.8, player.height, 0.8) // Player bounding box size
             );

             for (const obj of objects) { // Check against collidable objects
                if (!obj.geometry) continue; // Skip if object somehow lost geometry
                 obj.geometry.computeBoundingBox();
                 const objBox = obj.geometry.boundingBox.clone().applyMatrix4(obj.matrixWorld);

                 if (playerBox.intersectsBox(objBox)) {
                     collisionDetected = true;
                     break; // Stop checking after first collision for this frame
                 }
             }

             if (collisionDetected) {
                 // Simple resolution: Move player back to previous position
                 controls.getObject().position.copy(prevPosition);
                 player.velocity.set(0, player.velocity.y, 0); // Stop movement but allow gravity/jump effect
                  console.log("Collision!");
             }

            // --- Ground Check & Gravity/Jump ---
            let onGround = false;
            raycaster.set(playerPos, new THREE.Vector3(0, -1, 0)); // Raycast down
            const groundIntersects = raycaster.intersectObjects([scene.getObjectByProperty('type', 'ground')].concat(objects), false); // Check ground + collidables below

            if (groundIntersects.length > 0 && groundIntersects[0].distance < player.height / 2 + 0.2) {
                // Check distance to ensure feet are close to ground/object below
                 onGround = true;
                 player.velocity.y = Math.max(0, player.velocity.y); // Stop downward movement
                 // Snap to ground slightly? (Optional)
                 // playerPos.y = groundIntersects[0].point.y + player.height / 2;
                 player.canJump = true; // Allow jumping again
            } else {
                onGround = false;
                 player.velocity.y -= 9.8 * delta * 2.0; // Apply gravity if in air
            }


            // Jumping
            if (jump.value && player.canJump && onGround) {
                player.velocity.y = 6.0; // Jump velocity upward
                player.canJump = false; // Prevent double jump
                onGround = false; // Player is now in the air
                 console.log("Jump!");
            }


             // Apply vertical velocity
             controls.getObject().position.y += player.velocity.y * delta;

            // Prevent falling through floor (safety net)
            if (controls.getObject().position.y < player.height / 2) {
                controls.getObject().position.y = player.height / 2;
                player.velocity.y = 0;
                player.canJump = true;
            }


            // --- Status Decay ---
            const decayRate = 0.05; // Units per second
            player.hunger -= decayRate * delta * (moveForward.value || moveBackward.value || moveLeft.value || moveRight.value ? 2 : 1); // More hunger when moving
            player.thirst -= decayRate * delta * 1.5;
            player.hunger = Math.max(0, player.hunger);
            player.thirst = Math.max(0, player.thirst);

             if (player.hunger <= 0 || player.thirst <= 0) {
                player.health -= decayRate * delta * 5; // Take damage when starving/dehydrated
                 player.health = Math.max(0, player.health);
             }

            if (player.health <= 0) {
                 // Game Over logic
                 console.log("Game Over!");
                 controls.unlock();
                 alert("You have perished!");
                 // Reset or show menu? For now, just stop animation.
                  // Optional: Reload the page to restart easily
                  // location.reload();
                  // Need to stop the animate loop: cancelAnimationFrame(animationFrameId); - requires storing the id
                  // For now, just log and unlock.
            }


            updateHUD(); // Update displayed values
        }

        function updateAnimals(delta) {
             const wanderDistance = 10;
             const detectionRadius = 20;

             animals.forEach(animal => {
                 const data = animal.userData;
                 const pos = animal.position;

                 // Check distance to player
                 const playerDist = pos.distanceTo(camera.position);

                 if (data.aiState === 'fleeing') {
                      if (!data.moveTarget || pos.distanceTo(data.moveTarget) < 1.0) {
                          // Reached flee target or no target, switch back to idle/wander
                          data.aiState = 'idle';
                          data.moveTarget = null;
                      }
                 } else if (playerDist < detectionRadius && data.aiState !== 'fleeing') { // Player is close, but not fleeing yet
                     // Simple: Just stand still maybe? Or start wandering more actively?
                     if (Math.random() < 0.01) { // Small chance to wander even if player is near
                        data.aiState = 'wander';
                     } else {
                         data.aiState = 'idle'; // Mostly idle when player nearby but not attacking
                         // Look at player? (More complex)
                     }

                 } else { // Player is far away or animal finished fleeing
                     if (data.aiState !== 'wander' && Math.random() < 0.02) { // Small chance to start wandering
                         data.aiState = 'wander';
                         data.moveTarget = null; // Clear previous target
                     }
                 }


                 // Movement Logic
                 if (data.aiState === 'wander' || data.aiState === 'fleeing') {
                      if (!data.moveTarget || pos.distanceTo(data.moveTarget) < 1.0) {
                          // Set new wander target if wandering, or stop if fleeing target reached (handled above)
                          if (data.aiState === 'wander') {
                              const wanderDir = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                              data.moveTarget = pos.clone().addScaledVector(wanderDir, wanderDistance);
                              // Basic world bounds check (crude)
                              data.moveTarget.x = Math.max(-145, Math.min(145, data.moveTarget.x));
                              data.moveTarget.z = Math.max(-145, Math.min(145, data.moveTarget.z));
                              // Avoid water check (basic box)
                              if (data.moveTarget.x > 20 && data.moveTarget.x < 100 && data.moveTarget.z > 20 && data.moveTarget.z < 100) {
                                  data.moveTarget = null; // Don't move into water zone
                                  data.aiState = 'idle';
                              }
                          }
                      }

                      if (data.moveTarget) {
                          const direction = data.moveTarget.clone().sub(pos).normalize();
                          const moveStep = direction.multiplyScalar(data.speed * delta);

                           // Rudimentary collision avoidance for animals (Check before moving)
                           let canMove = true;
                           const nextPos = pos.clone().add(moveStep);
                           const animalBox = new THREE.Box3().setFromCenterAndSize(nextPos, new THREE.Vector3(1.4, 1.4, 1.4)); // Slightly larger than mesh

                           for (const obj of objects) {
                               if (obj === animal) continue; // Don't collide with self
                               obj.geometry.computeBoundingBox();
                               const objBox = obj.geometry.boundingBox.clone().applyMatrix4(obj.matrixWorld);
                               if (animalBox.intersectsBox(objBox)) {
                                   canMove = false;
                                   data.moveTarget = null; // Hit something, pick new target next time
                                   data.aiState = 'idle';
                                   break;
                               }
                           }

                           if (canMove) {
                               animal.position.add(moveStep);
                               // Make animal face movement direction (optional)
                               // animal.lookAt(data.moveTarget); // Can cause jerky rotation
                           }
                      }
                 }
             });
         }

        function updateInteractionPrompt() {
            const lookingAt = getObjectPlayerIsLookingAt();
            let showPrompt = false;
            let promptText = "Press [E] to interact";

            if (controls.isLocked && lookingAt && lookingAt.distance < interactionDistance) {
                const type = lookingAt.object.userData.type;
                 // Customize prompt based on object type
                if (type === 'barrel' || type === 'crate') {
                    showPrompt = true;
                    promptText = `Press [E] to Search ${lookingAt.object.userData.name}`;
                } else if (type === 'tree' || type === 'rock') {
                    showPrompt = true;
                    promptText = `Press Left-Click with Tool to Harvest`; // Or [E] if using E for harvest
                } else if (type === 'grass' || type === 'scrap' || type === 'pickup') {
                     showPrompt = true;
                     promptText = `Press [E] to Collect ${lookingAt.object.userData.name || lookingAt.object.userData.resource}`;
                 } else if (type === 'water') {
                     showPrompt = true;
                     promptText = `Press [E] to Fill Canteen`;
                 } else if (type === 'animal' && lookingAt.object.userData.health <= 0) {
                     // Allow harvesting dead animal? (Needs knife equipped check)
                      showPrompt = true;
                      promptText = `Press Left-Click with Knife to Butcher`;
                 } else if (type === 'campfire') {
                      showPrompt = true;
                      promptText = `Press [E] to Use Campfire`; // Open cooking UI?
                 }
                  // Add prompts for workbench, forge etc.
            }

            interactionPromptEl.style.display = showPrompt ? 'block' : 'none';
            if (showPrompt) interactionPromptEl.textContent = promptText;
        }


        function getObjectPlayerIsLookingAt(maxDistance = interactionDistance) {
            if (!camera) return null;
            raycaster.setFromCamera(pointer, camera); // Ray from camera center
            const intersects = raycaster.intersectObjects(scene.children, true); // Check all descendants

            for (let i = 0; i < intersects.length; i++) {
                 // Find the first interactable object within range (ignore ground, sky, non-collidables unless specifically interactable like grass)
                 let obj = intersects[i].object;
                 // Traverse up parent hierarchy if needed (e.g., hitting part of a complex model)
                 while (obj.parent && !obj.userData.type) {
                     obj = obj.parent;
                 }

                 const data = obj.userData;
                 if (data && data.type && data.type !== 'ground' && data.type !== 'sky' && data.type !== 'building_part') { // Add more non-interactive types if needed
                     if (intersects[i].distance <= maxDistance) {
                         return { object: obj, distance: intersects[i].distance, point: intersects[i].point };
                     } else {
                         return null; // Hit something, but it's too far
                     }
                 }
            }
            return null; // Didn't hit anything relevant
        }

         function getGroundIntersect() {
             raycaster.setFromCamera(pointer, camera);
             const intersects = raycaster.intersectObject(scene.getObjectByProperty('type', 'ground'), false);
             if (intersects.length > 0) {
                 return intersects[0];
             }
             return null;
         }

         let animationFrameId = null;
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (controls.isLocked || player.isInventoryOpen || player.isCraftingOpen || player.isContainerOpen) { // Update player even if menus are open for status decay
                updatePlayer(delta);
                updateAnimals(delta); // Update animal movement/AI
                updateInteractionPrompt(); // Show/hide interaction text

                 // Update placeables (e.g., campfires cooking)
                 placeables.forEach(p => {
                     if (p.userData.type === 'campfire') {
                         processCampfire(p, delta);
                     }
                     // Add updates for other placeables if needed (e.g., forge smelting timer)
                 });
            }


            renderer.render(scene, camera);
        }


        // --- Initialization ---
        startGameBtn.addEventListener('click', () => {
             const startResources = parseInt(document.getElementById('startResources').value) || 0;
             const playerSpeed = parseFloat(document.getElementById('playerSpeed').value) || 5.0;
             const playerHeight = parseFloat(document.getElementById('playerHeight').value) || 1.8;

             const settings = {
                 startResources: startResources,
                 playerSpeed: playerSpeed,
                 playerHeight: playerHeight
             };

             settingsMenuEl.style.display = 'none'; // Hide settings menu
             initScene(settings); // Initialize and start the game
         });

         // Show settings menu on page load
         settingsMenuEl.style.display = 'block';


    </script>
</body>
</html>
