<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5 Survival Game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background-color: rgba(255, 255, 255, 0.5); transform: translate(-50%, -50%); border-radius: 50%; }
        #inventory { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60%; height: 70%; background-color: rgba(0, 0, 0, 0.8); border: 2px solid #555; display: none; /* Toggled by JS */ padding: 20px; box-sizing: border-box; pointer-events: all; color: white; }
        #inventory h2 { text-align: center; margin-top: 0; }
        .inventory-grid, .quickbar-grid { display: grid; gap: 10px; margin-bottom: 20px; }
        .inventory-grid { grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); }
        .quickbar-grid { grid-template-columns: repeat(10, 1fr); /* 10 quick slots */ }
        .slot { width: 60px; height: 60px; background-color: #444; border: 1px solid #666; display: flex; align-items: center; justify-content: center; flex-direction: column; font-size: 10px; position: relative; }
        .slot .item-name { font-weight: bold; margin-bottom: 3px; }
        .slot .item-count { position: absolute; bottom: 3px; right: 5px; font-size: 12px; background-color: rgba(0,0,0,0.7); padding: 1px 3px; border-radius: 3px;}
        #quickbar-display { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; background-color: rgba(0, 0, 0, 0.5); padding: 5px; border-radius: 5px; pointer-events: all; }
        .q-slot { width: 50px; height: 50px; background-color: #555; border: 1px solid #888; display: flex; align-items: center; justify-content: center; flex-direction: column; font-size: 9px; position: relative;}
        .q-slot.selected { border: 2px solid yellow; }
        .q-slot .item-name { font-weight: bold; }
        .q-slot .item-count { position: absolute; bottom: 2px; right: 3px; font-size: 11px; background-color: rgba(0,0,0,0.7); padding: 1px 3px; border-radius: 3px;}
        #message { position: absolute; bottom: 80px; left: 10px; background-color: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 4px; max-width: 300px; font-size: 14px; }
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(20, 20, 30, 0.95); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; }
        #start-screen label { margin-top: 15px; }
        #start-screen input, #start-screen select { margin-left: 10px; padding: 5px; }
        #start-screen button { margin-top: 30px; padding: 10px 20px; font-size: 16px; cursor: pointer; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>Survival Game Setup</h1>
        <div>
            <label for="start-wood">Starting Wood:</label>
            <input type="number" id="start-wood" value="10" min="0" max="100">
        </div>
        <div>
            <label for="start-stone">Starting Stone:</label>
            <input type="number" id="start-stone" value="5" min="0" max="100">
        </div>
        <div>
            <label for="player-speed">Player Speed:</label>
            <input type="range" id="player-speed" min="0.02" max="0.15" step="0.01" value="0.05">
            <span id="speed-value">0.05</span>
        </div>
         <div>
            <label for="player-height">Player Height (View Offset):</label>
            <input type="range" id="player-height" min="-0.5" max="0.5" step="0.1" value="0">
             <span id="height-value">0</span>
        </div>
        <button id="start-button">Start Game</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="quickbar-display">
            <!-- Quick bar slots will be generated by JS -->
        </div>
        <div id="message"></div>
        <div id="inventory">
            <h2>Inventory</h2>
            <p>Quick Bar (SHIFT+Click to move)</p>
            <div class="quickbar-grid" id="inventory-quickbar">
                 <!-- Quick bar slots in inventory view -->
            </div>
             <p>Main Inventory</p>
            <div class="inventory-grid" id="inventory-main">
                 <!-- Inventory slots -->
            </div>
            <p style="position: absolute; bottom: 10px; right: 10px;">Press TAB to close</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('ui-layer');
        const inventoryDisplay = document.getElementById('inventory');
        const quickbarDisplay = document.getElementById('quickbar-display');
        const messageDisplay = document.getElementById('message');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const inventoryQuickbarGrid = document.getElementById('inventory-quickbar');
        const inventoryMainGrid = document.getElementById('inventory-main');


        let screenWidth = window.innerWidth;
        let screenHeight = window.innerHeight;
        canvas.width = screenWidth;
        canvas.height = screenHeight;

        // --- Game State ---
        let gameRunning = false;
        let showInventory = false;
        let keys = {}; // Keep track of pressed keys

        // --- Player ---
        let player = {
            x: 3.5, // Starting position
            y: 8.5,
            angle: Math.PI * 1.5, // Facing direction (radians)
            fov: Math.PI / 3, // Field of view (60 degrees)
            speed: 0.05,
            rotSpeed: 0.04,
            height: 0.0, // Vertical view offset
            inventory: [],
            quickbar: new Array(10).fill(null), // 10 quick slots
            selectedQuickSlot: 0,
            // Stats (placeholders)
            health: 100,
            hunger: 100,
            thirst: 100,
        };

        // --- World ---
        const mapWidth = 16;
        const mapHeight = 16;
        // 0: Empty, 1: Stone Wall, 2: Tree Trunk, 3: Rock, 4: Building Wall, 5: Water (non-collidable floor)
        const map = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 2, 0, 0, 0, 0, 4, 4, 4, 0, 0, 3, 1],
            [1, 0, 5, 5, 0, 0, 0, 0, 0, 4, 0, 4, 0, 2, 0, 1],
            [1, 0, 5, 5, 0, 3, 0, 0, 0, 4, 0, 4, 0, 0, 0, 1],
            [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 4, 4, 4, 0, 0, 3, 0, 0, 2, 0, 0, 0, 0, 0, 1],
            [1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 1],
            [1, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 1],
            [1, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1],
            [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];

        // Sprites/Objects in the world
        // type: 'tree', 'rock_l', 'grass', 'scrap', 'barrel', 'crate', 'animal_deer', 'campfire', 'forge' ...
        // state can track things like 'searched', 'burning', 'hp' etc.
        let worldObjects = [
            { x: 2.5, y: 2.5, type: 'tree', texture: '#228B22', radius: 0.4 }, // Simple representation
            { x: 5.5, y: 3.5, type: 'rock_l', texture: '#808080', radius: 0.3 },
            { x: 6.5, y: 10.5, type: 'rock_l', texture: '#808080', radius: 0.3 },
            { x: 9.5, y: 9.5, type: 'tree', texture: '#228B22', radius: 0.4 },
            { x: 10.5, y: 1.5, type: 'crate', texture: '#D2B48C', radius: 0.2, searchable: true, searched: false, loot: [{id: 'nails', quantity: 15}] }, // Inside building
            { x: 11.5, y: 2.5, type: 'crate', texture: '#D2B48C', radius: 0.2, searchable: true, searched: false, loot: [{id: 'scrap_metal', quantity: 5}] }, // Inside building
            { x: 4.5, y: 14.5, type: 'tree', texture: '#228B22', radius: 0.4 },
            { x: 14.5, y: 14.5, type: 'tree', texture: '#228B22', radius: 0.4 },
            { x: 1.5, y: 14.5, type: 'rock_l', texture: '#808080', radius: 0.3 },
            { x: 9.5, y: 13.5, type: 'rock_l', texture: '#808080', radius: 0.3 },
            { x: 7.5, y: 6.5, type: 'barrel', texture: '#A0522D', radius: 0.25, searchable: true, searched: false, loot: [{id: 'canteen_water_dirty', quantity: 1}] },
            { x: 13.5, y: 10.5, type: 'scrap', texture: '#777788', radius: 0.15, collectable: true },
             { x: 3.5, y: 5.5, type: 'grass', texture: '#55dd55', radius: 0.1, collectable: true },
             { x: 4.0, y: 5.8, type: 'grass', texture: '#55dd55', radius: 0.1, collectable: true },
             { x: 3.8, y: 6.1, type: 'grass', texture: '#55dd55', radius: 0.1, collectable: true },
            // TODO: Add animated animals (requires more complex state and rendering)
        ];

        // --- Items & Crafting (Simplified Definitions) ---
        const items = {
            'wood': { name: 'Wood', stack: 50 },
            'stone': { name: 'Stone', stack: 50 },
            'rope': { name: 'Rope', stack: 20 },
            'scrap_metal': { name: 'Scrap Metal', stack: 30 },
            'nails': { name: 'Nails', stack: 50 },
            'meat_raw': { name: 'Raw Meat', stack: 10 },
            'meat_cooked': { name: 'Cooked Meat', stack: 10 },
            'leather': { name: 'Leather', stack: 20 },
            'fat': { name: 'Animal Fat', stack: 10 },
            'axe': { name: 'Axe', stack: 1, tool: 'chop' },
            'pickaxe': { name: 'Pickaxe', stack: 1, tool: 'mine' },
            'knife': { name: 'Knife', stack: 1, tool: 'harvest_animal' },
            'canteen_empty': { name: 'Empty Canteen', stack: 1 },
            'canteen_water_dirty': { name: 'Dirty Water Canteen', stack: 1 },
            'canteen_water_clean': { name: 'Clean Water Canteen', stack: 1 },
            'campfire': { name: 'Campfire', stack: 5, placeable: true },
            'crafting_table': { name: 'Crafting Table', stack: 1, placeable: true },
            'forge': { name: 'Forge', stack: 1, placeable: true },
            'tall_grass_resource': { name: 'Tall Grass Fibers', stack: 50 } // Resource from grass
        };

        const recipes = {
            'axe': { requires: [{ id: 'wood', quantity: 3 }, { id: 'stone', quantity: 2 }, {id: 'rope', quantity: 1}], yields: { id: 'axe', quantity: 1 } },
            'pickaxe': { requires: [{ id: 'wood', quantity: 3 }, { id: 'stone', quantity: 3 }, {id: 'rope', quantity: 1}], yields: { id: 'pickaxe', quantity: 1 } },
            'rope': { requires: [{ id: 'tall_grass_resource', quantity: 5 }], yields: { id: 'rope', quantity: 1 } },
            'campfire': { requires: [{ id: 'wood', quantity: 5 }, { id: 'stone', quantity: 8 }], yields: { id: 'campfire', quantity: 1 } },
            // Add crafting table, forge recipes later... requires more crafting logic tiers
        };

        // --- Settings ---
        const speedSlider = document.getElementById('player-speed');
        const speedValueDisplay = document.getElementById('speed-value');
        const heightSlider = document.getElementById('player-height');
        const heightValueDisplay = document.getElementById('height-value');

        speedSlider.oninput = () => { speedValueDisplay.textContent = parseFloat(speedSlider.value).toFixed(2); };
        heightSlider.oninput = () => { heightValueDisplay.textContent = parseFloat(heightSlider.value).toFixed(1); };

        // --- Initialization ---
        function initGame() {
            // Apply settings
            player.speed = parseFloat(speedSlider.value);
            player.height = parseFloat(heightSlider.value);

            // Add starting resources
            const startWood = parseInt(document.getElementById('start-wood').value) || 0;
            const startStone = parseInt(document.getElementById('start-stone').value) || 0;
            if (startWood > 0) addItemToInventory('wood', startWood);
            if (startStone > 0) addItemToInventory('stone', startStone);

            // Add starting gear
            addItemToInventory('axe', 1);
            addItemToInventory('pickaxe', 1);
            addItemToInventory('knife', 1);
            addItemToInventory('canteen_empty', 1);

            // Assign first available items to quickbar
            updateQuickbarFromInventory();

            startScreen.style.display = 'none';
            gameRunning = true;
            showMessage("Game started. Use WASD to move, Arrows to look, E to interact, TAB for inventory.", 5000);
            requestAnimationFrame(gameLoop);
        }

        startButton.addEventListener('click', initGame);

        // --- Input Handling ---
        window.addEventListener('keydown', (e) => { keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });
        window.addEventListener('keydown', handleSingleKeyPress); // For actions like inventory toggle

        function handleSingleKeyPress(e) {
            if (!gameRunning) return;

            if (e.code === 'Tab') {
                e.preventDefault(); // Prevent tabbing out of the game
                showInventory = !showInventory;
                inventoryDisplay.style.display = showInventory ? 'block' : 'none';
                if(showInventory) updateInventoryUI();
            }

             // Quick slot selection (1-0 keys)
            if (e.code.startsWith('Digit')) {
                const slotIndex = parseInt(e.code.slice(5)); // "Digit5" -> 5
                 if (slotIndex >= 1 && slotIndex <= 9) {
                     player.selectedQuickSlot = slotIndex - 1;
                 } else if (slotIndex === 0) { // Key 0 selects slot 10
                     player.selectedQuickSlot = 9;
                 }
                 updateQuickbarDisplay();
            }

            if (e.code === 'KeyE') {
                 handleInteraction();
            }
        }

         // Handle inventory clicks (Shift + Click)
         inventoryDisplay.addEventListener('click', (e) => {
             if (!e.shiftKey) return; // Only handle shift+clicks

             const targetSlot = e.target.closest('.slot, .q-slot');
             if (!targetSlot) return;

             const isQuickbarSlot = targetSlot.classList.contains('q-slot') || targetSlot.parentElement.id === 'inventory-quickbar';
             const slotIndex = parseInt(targetSlot.dataset.index);
             const sourceContainer = isQuickbarSlot ? player.quickbar : player.inventory;
             const targetContainer = isQuickbarSlot ? player.inventory : player.quickbar;
             const targetPushMethod = isQuickbarSlot ? addItemToInventory : addItemToQuickbar; // Function to add to target

             const item = sourceContainer[slotIndex];

             if (item) {
                 // Try to add to the target container
                 const remainingQuantity = targetPushMethod(item.id, item.quantity, !isQuickbarSlot); // If moving to quickbar, try specific slot

                 if (remainingQuantity === 0) {
                     // Successfully moved all
                     if (isQuickbarSlot) {
                         player.quickbar[slotIndex] = null;
                     } else {
                         player.inventory.splice(slotIndex, 1); // Remove from inventory array
                     }
                 } else if (remainingQuantity < item.quantity) {
                    // Partially moved (filled a stack or slot)
                     item.quantity = remainingQuantity; // Update quantity in source
                 } else {
                     showMessage("Cannot move item - target full or invalid.", 2000);
                 }

                 updateInventoryUI(); // Refresh both inventory and quickbar display
                 updateQuickbarDisplay();
             }
         });


        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameRunning) return;

            const deltaTime = (timestamp - lastTime) / 1000; // Time difference in seconds
            lastTime = timestamp;

            update(deltaTime);
            render();

            requestAnimationFrame(gameLoop);
        }

        // --- Update Logic ---
        function update(deltaTime) {
            if (showInventory) return; // Pause game updates when inventory is open

            handleMovement(deltaTime);
            // --- Placeholder Updates ---
            // updateAI(deltaTime);
            // updateWorldTimers(deltaTime); // For cooking, plant growth etc.
            // updatePlayerStats(deltaTime); // Hunger, thirst decrease
        }

        function handleMovement(deltaTime) {
            const moveSpeed = player.speed;
            const rotSpeed = player.rotSpeed;
            let dx = 0;
            let dy = 0;

            // Rotation
            if (keys['ArrowLeft']) {
                player.angle -= rotSpeed;
            }
            if (keys['ArrowRight']) {
                player.angle += rotSpeed;
            }
             // Keep angle within 0 to 2PI
            player.angle = (player.angle + Math.PI * 2) % (Math.PI * 2);


            // Movement (Forward/Backward)
            if (keys['KeyW']) {
                dx += Math.cos(player.angle) * moveSpeed;
                dy += Math.sin(player.angle) * moveSpeed;
            }
            if (keys['KeyS']) {
                dx -= Math.cos(player.angle) * moveSpeed;
                dy -= Math.sin(player.angle) * moveSpeed;
            }
            // Movement (Strafing)
            if (keys['KeyA']) {
                dx += Math.sin(player.angle) * moveSpeed; // Perpendicular direction
                dy -= Math.cos(player.angle) * moveSpeed;
            }
            if (keys['KeyD']) {
                dx -= Math.sin(player.angle) * moveSpeed;
                dy += Math.cos(player.angle) * moveSpeed;
            }

            // Collision Detection
            const newX = player.x + dx;
            const newY = player.y + dy;
            const collisionMargin = 0.1; // Prevent sticking exactly to walls

            // Check collision with walls based on map grid
            const currentMapX = Math.floor(player.x);
            const currentMapY = Math.floor(player.y);
            const targetMapX = Math.floor(newX + Math.sign(dx) * collisionMargin);
            const targetMapY = Math.floor(newY + Math.sign(dy) * collisionMargin);

            // Check X movement collision
            if (isWall(targetMapX, currentMapY)) {
                 // Stop X movement
                 player.x = Math.floor(newX) + (dx > 0 ? (1 - collisionMargin) : collisionMargin);
                 dx = 0; // Prevent further adjustment based on blocked X
            }

             // Check Y movement collision (use potentially updated targetMapX if X wasn't blocked)
             const finalTargetMapX = Math.floor(player.x + dx + Math.sign(dx) * collisionMargin); // Recheck X for Y collision calc
             if (isWall(finalTargetMapX, targetMapY)) {
                 // Stop Y movement
                 player.y = Math.floor(newY) + (dy > 0 ? (1 - collisionMargin) : collisionMargin);
                 dy = 0; // Prevent further adjustment
             }


            // Apply final movement if no collision stopped it
            player.x += dx;
            player.y += dy;

             // --- Placeholder Collision with Objects ---
             // This would be more complex, checking bounding boxes or circles
             /*
             for (const obj of worldObjects) {
                 if (obj.collidable) { // Need to add a 'collidable' property to objects like large rocks/trees
                     const dist = Math.hypot(newX - obj.x, newY - obj.y);
                     if (dist < (player.radius + obj.radius)) { // Assuming player/object radius
                          // Handle collision response (e.g., slide along, stop)
                          // For simplicity, we are only doing map collisions for now.
                     }
                 }
             }
             */
        }

        function isWall(x, y) {
            if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) {
                return true; // Out of bounds is a wall
            }
            const tile = map[y][x];
            // Define which tile types are collidable walls
            return tile === 1 || tile === 2 || tile === 3 || tile === 4;
        }

         function handleInteraction() {
             // Raycast forward a short distance to see what the player is looking at
             const interactDist = 1.5; // How far the player can interact
             const step = 0.1;
             let currentX = player.x;
             let currentY = player.y;
             const angleCos = Math.cos(player.angle);
             const angleSin = Math.sin(player.angle);

             for (let d = 0; d < interactDist; d += step) {
                 currentX += angleCos * step;
                 currentY += angleSin * step;
                 const mapX = Math.floor(currentX);
                 const mapY = Math.floor(currentY);

                 // Check for map tile interaction (e.g., hitting a tree trunk)
                 if (isWall(mapX, mapY)) {
                     const tileType = map[mapY][mapX];
                     const heldItem = player.quickbar[player.selectedQuickSlot];
                     const toolType = heldItem && items[heldItem.id] ? items[heldItem.id].tool : null;

                     if (tileType === 2 && toolType === 'chop') { // Tree Trunk
                         showMessage("Chopping tree... (Placeholder)", 1500);
                         // TODO: Implement HP system for trees, drop wood on destroy
                         // Example: Drop wood
                         addItemToInventory('wood', 2);
                         // For now, just a message
                         return; // Stop checking once something is hit
                     } else if (tileType === 3 && toolType === 'mine') { // Rock
                         showMessage("Mining rock... (Placeholder)", 1500);
                         // TODO: Implement HP system for rocks, drop stone
                         addItemToInventory('stone', 1);
                         return;
                     } else if (tileType === 4){
                         showMessage("A solid building wall.", 1500);
                         return;
                     } else {
                          showMessage("Hit a wall.", 1500);
                         return; // Hit a non-interactive wall
                     }
                 }

                 // Check for object interaction
                 // Sort objects by distance to interact with the closest one first
                 worldObjects.sort((a, b) => {
                    const distA = Math.hypot(player.x - a.x, player.y - a.y);
                    const distB = Math.hypot(player.x - b.x, player.y - b.y);
                    return distA - distB;
                 });

                 for (let i = 0; i < worldObjects.length; i++) {
                     const obj = worldObjects[i];
                     const distToObject = Math.hypot(currentX - obj.x, currentY - obj.y);

                     if (distToObject < obj.radius) {
                        if (obj.searchable) {
                            if (!obj.searched) {
                                showMessage(`Searching ${obj.type}... Found items!`, 2000);
                                obj.loot.forEach(lootItem => addItemToInventory(lootItem.id, lootItem.quantity));
                                obj.searched = true;
                                obj.texture = '#6B4A24'; // Change appearance slightly
                            } else {
                                showMessage(`${obj.type} is empty.`, 1500);
                            }
                        } else if (obj.collectable) {
                             if (obj.type === 'scrap') {
                                 showMessage("Collected scrap metal.", 1500);
                                 addItemToInventory('scrap_metal', 1);
                                 worldObjects.splice(i, 1); // Remove collected object
                             } else if (obj.type === 'grass') {
                                 showMessage("Harvested tall grass.", 1500);
                                 addItemToInventory('tall_grass_resource', 1);
                                  worldObjects.splice(i, 1); // Remove collected object
                             }
                             // Add other collectables here (nails etc.)
                        } else {
                            showMessage(`Interacting with ${obj.type}... (Placeholder)`, 1500);
                            // TODO: Add specific interactions (open forge UI, place meat on campfire)
                        }
                         return; // Stop checking after interacting with an object
                     }
                 }
             }
             // If loop finishes without hitting anything interactable
             // showMessage("Nothing to interact with here.", 1000);
         }

        // --- Rendering ---
        function render() {
            // Clear screen
            ctx.fillStyle = '#333'; // Fallback background
            ctx.fillRect(0, 0, screenWidth, screenHeight);

            // Draw Floor and Ceiling
            // Ceiling
            ctx.fillStyle = '#87CEEB'; // Light Sky Blue
            ctx.fillRect(0, 0, screenWidth, screenHeight / 2 + screenHeight * player.height);
            // Floor
            ctx.fillStyle = '#708090'; // Slate Gray
            ctx.fillRect(0, screenHeight / 2 + screenHeight * player.height, screenWidth, screenHeight / 2 - screenHeight * player.height);


            // --- Raycasting Walls ---
            const numRays = screenWidth;
            const angleStep = player.fov / numRays;
            let rayAngle = player.angle - player.fov / 2;

            // Z-buffer for sprites
            const depthBuffer = new Array(screenWidth).fill(Infinity);


            for (let i = 0; i < numRays; i++) {
                let rayCos = Math.cos(rayAngle);
                let raySin = Math.sin(rayAngle);
                let distanceToWall = 0;
                let hitWall = false;
                let wallX = 0, wallY = 0; // Coordinates of the wall hit
                let hitVertical = false; // Was the wall hit vertical or horizontal side?

                let currentX = player.x;
                let currentY = player.y;
                let stepX = (rayCos > 0) ? 1 : -1;
                let stepY = (raySin > 0) ? 1 : -1;

                // Distance to next vertical grid line
                let deltaDistX = Math.abs(1 / rayCos);
                let sideDistX = (rayCos > 0) ? (Math.floor(currentX) + 1.0 - currentX) * deltaDistX : (currentX - Math.floor(currentX)) * deltaDistX;

                // Distance to next horizontal grid line
                let deltaDistY = Math.abs(1 / raySin);
                let sideDistY = (raySin > 0) ? (Math.floor(currentY) + 1.0 - currentY) * deltaDistY : (currentY - Math.floor(currentY)) * deltaDistY;

                let mapCheckX = Math.floor(currentX);
                let mapCheckY = Math.floor(currentY);

                let wallType = 0;

                // DDA Algorithm
                while (!hitWall && distanceToWall < 20) { // Max render distance 20 units
                    if (sideDistX < sideDistY) {
                        sideDistX += deltaDistX;
                        mapCheckX += stepX;
                        distanceToWall = (mapCheckX - player.x + (1 - stepX) / 2) / rayCos; // Use distance calculation suitable for sideDist comparison
                        hitVertical = true;
                    } else {
                        sideDistY += deltaDistY;
                        mapCheckY += stepY;
                        distanceToWall = (mapCheckY - player.y + (1 - stepY) / 2) / raySin;
                        hitVertical = false;
                    }

                    if (mapCheckX >= 0 && mapCheckX < mapWidth && mapCheckY >= 0 && mapCheckY < mapHeight) {
                        wallType = map[mapCheckY][mapCheckX];
                        if (isWall(mapCheckX, mapCheckY)) { // Check if it's a *collidable* wall for rendering
                            hitWall = true;
                            wallX = mapCheckX;
                            wallY = mapCheckY;
                        } else if (wallType === 5) { // Check for water tile *after* potential wall hit
                           // Draw water surface before potentially hitting a wall beyond it
                           // Calculate intersection point with water tile boundary if needed
                           // For simplicity, we'll handle floor color based on ray cast below
                        }
                    } else {
                        // Hit edge of map, treat as wall? Or just stop ray?
                        hitWall = true; // Stop ray if it goes out of bounds
                        distanceToWall = 20;
                    }
                }

                 // Correct distance to prevent fisheye
                 const correctedDistance = distanceToWall * Math.cos(rayAngle - player.angle);
                 depthBuffer[i] = correctedDistance; // Store distance for sprite depth testing


                // Calculate wall height
                let lineHeight = Math.floor(screenHeight / correctedDistance);
                 if (lineHeight < 0) lineHeight = screenHeight; // Avoid negative heights on very close walls


                // Calculate draw start and end points, applying player height offset
                let drawStart = -lineHeight / 2 + screenHeight / 2 + screenHeight * player.height;
                if (drawStart < 0) drawStart = 0;
                let drawEnd = lineHeight / 2 + screenHeight / 2 + screenHeight * player.height;
                if (drawEnd >= screenHeight) drawEnd = screenHeight - 1;

                // Wall Color/Texture based on type and side
                 let wallColor = '#666'; // Default Gray
                 switch (wallType) {
                     case 1: wallColor = '#A9A9A9'; break; // Stone Wall
                     case 2: wallColor = '#8B4513'; break; // Tree Trunk
                     case 3: wallColor = '#696969'; break; // Rock
                     case 4: wallColor = '#BDB76B'; break; // Building Wall
                 }
                 // Make vertical sides slightly darker for depth perception
                 if (hitVertical) {
                     // Simple darkening: reduce RGB values
                     let r = parseInt(wallColor.slice(1, 3), 16);
                     let g = parseInt(wallColor.slice(3, 5), 16);
                     let b = parseInt(wallColor.slice(5, 7), 16);
                     r = Math.max(0, r - 40);
                     g = Math.max(0, g - 40);
                     b = Math.max(0, b - 40);
                     wallColor = `rgb(${r},${g},${b})`;
                 }

                // Draw the wall slice
                ctx.beginPath();
                ctx.strokeStyle = wallColor;
                ctx.lineWidth = 1; // Draw thin lines for walls
                ctx.moveTo(i + 0.5, drawStart); // +0.5 for crisp lines
                ctx.lineTo(i + 0.5, drawEnd);
                ctx.stroke();


                 // Draw Floor casting up to the wall
                 let floorTexX, floorTexY;
                 let currentDist = 0;
                 for (let y = Math.floor(drawEnd) + 1; y < screenHeight; y++) {
                     currentDist = screenHeight / (2.0 * (y - screenHeight * player.height) - screenHeight); // distance to floor point
                     let weight = currentDist / correctedDistance;

                     let currentFloorX = weight * (wallX + (hitVertical ? (rayCos > 0 ? 0 : 1) : (currentX + rayCos * correctedDistance))) + (1.0 - weight) * player.x;
                     let currentFloorY = weight * (wallY + (hitVertical ? (currentY + raySin * correctedDistance) : (raySin > 0 ? 0 : 1))) + (1.0 - weight) * player.y;


                     let floorMapX = Math.floor(currentFloorX);
                     let floorMapY = Math.floor(currentFloorY);

                     // Simple floor color based on map tile below
                     let floorColor = '#708090'; // Default floor
                      if (floorMapX >= 0 && floorMapX < mapWidth && floorMapY >= 0 && floorMapY < mapHeight) {
                          if (map[floorMapY][floorMapX] === 5) {
                              floorColor = '#4682B4'; // Water color (Steel Blue)
                          } else if (map[floorMapY][floorMapX] === 0 && Math.random() < 0.05) { // Add some variation
                             floorColor = '#6A7D8B'; // Slightly different gray
                          }
                     }


                     ctx.fillStyle = floorColor;
                     // Add simple shading based on distance
                      const darkness = Math.min(1, Math.max(0, 1 - currentDist / 10)); // Darken distant floor
                      let r = parseInt(floorColor.slice(1, 3), 16) * darkness;
                      let g = parseInt(floorColor.slice(3, 5), 16) * darkness;
                      let b = parseInt(floorColor.slice(5, 7), 16) * darkness;
                      ctx.fillStyle = `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;

                     ctx.fillRect(i, y, 1, 1); // Draw floor pixel

                     // Could draw ceiling similarly here if needed
                 }


                // Increment angle for the next ray
                rayAngle += angleStep;
            }


            // --- Render Sprites ---
             renderSprites(depthBuffer);


            // --- Render UI ---
            if (!showInventory) { // Only draw HUD if inventory is closed
                 updateQuickbarDisplay(); // Ensure quickbar is up-to-date
                 // Draw selected item name (optional)
                 const selectedItem = player.quickbar[player.selectedQuickSlot];
                 if (selectedItem) {
                     ctx.fillStyle = "white";
                     ctx.font = "16px sans-serif";
                     ctx.textAlign = "center";
                     ctx.fillText(items[selectedItem.id].name, screenWidth / 2, 30);
                 }
             }
        }

         function renderSprites(depthBuffer) {
            // Sort sprites by distance from player (far to near) for correct occlusion
             worldObjects.sort((a, b) => {
                 const distA = Math.hypot(player.x - a.x, player.y - a.y);
                 const distB = Math.hypot(player.x - b.x, player.y - b.y);
                 return distB - distA; // Farthest first
             });

             for (const sprite of worldObjects) {
                 // Translate sprite position to relative to camera
                 const spriteX = sprite.x - player.x;
                 const spriteY = sprite.y - player.y;

                 // Inverse camera matrix transformation
                 const invDet = 1.0 / (-Math.sin(player.angle) * player.fov - Math.cos(player.angle) * 0); // Simplified assuming camera plane is perpendicular
                 const transformX = invDet * (-Math.sin(player.angle) * spriteX - Math.cos(player.angle) * spriteY);
                 const transformY = invDet * (Math.cos(player.angle) * spriteX - Math.sin(player.angle) * spriteY); // This is the depth

                 if (transformY > 0.5) { // Only draw sprites in front of the player and not too close
                     const spriteScreenX = Math.floor((screenWidth / 2) * (1 + transformX / transformY));

                     // Calculate sprite height and width based on distance
                      const spriteHeight = Math.abs(Math.floor(screenHeight / transformY));
                      const spriteWidth = spriteHeight; // Assume square sprites for simplicity

                     // Calculate draw start/end points on screen
                      const drawStartY = Math.floor(-spriteHeight / 2 + screenHeight / 2 + screenHeight * player.height);
                      const drawEndY = Math.floor(spriteHeight / 2 + screenHeight / 2 + screenHeight * player.height);
                      const drawStartX = Math.floor(-spriteWidth / 2 + spriteScreenX);
                      const drawEndX = Math.floor(spriteWidth / 2 + spriteScreenX);


                     // Draw the sprite column by column
                     for (let stripe = drawStartX; stripe < drawEndX; stripe++) {
                         // Check if stripe is within screen bounds and in front of a wall (using depth buffer)
                         if (stripe >= 0 && stripe < screenWidth && transformY < depthBuffer[stripe]) {
                             // Simple colored rectangle for the sprite
                             ctx.fillStyle = sprite.texture || '#FF00FF'; // Magenta if no texture defined

                              // Adjust Y draw coords based on sprite size ratio maybe? For now, full column slice.
                              const finalDrawY = Math.max(0, drawStartY);
                              const finalDrawH = Math.min(screenHeight - 1, drawEndY) - finalDrawY;


                              if(finalDrawH > 0) {
                                  ctx.fillRect(stripe, finalDrawY, 1, finalDrawH);
                               }
                         }
                     }
                 }
             }
         }

        // --- Inventory & Crafting Logic ---

         function findItemSlot(container, itemId) {
             for (let i = 0; i < container.length; i++) {
                 if (container[i] && container[i].id === itemId) {
                     return i;
                 }
             }
             return -1;
         }

         function findStackableSlot(container, itemId) {
             const itemData = items[itemId];
             if (!itemData) return -1;
             const maxStack = itemData.stack || 1;

             for (let i = 0; i < container.length; i++) {
                 if (container[i] && container[i].id === itemId && container[i].quantity < maxStack) {
                     return i;
                 }
             }
             return -1;
         }

          function findEmptySlot(container) {
             for (let i = 0; i < container.length; i++) {
                 if (container[i] === null) {
                     return i;
                 }
             }
              // For inventory array, we can just push if it's not size-limited like quickbar
              if (Array.isArray(container) && container === player.inventory) {
                  return container.length; // Indicates can push to end
              }
             return -1;
         }

        function addItemToInventory(itemId, quantity) {
            const itemData = items[itemId];
            if (!itemData) {
                console.error("Unknown item ID:", itemId);
                return quantity; // Return original quantity if item doesn't exist
            }
            const maxStack = itemData.stack || 1;
            let remainingQuantity = quantity;

            // 1. Try stacking onto existing items in inventory
            let stackableSlot;
            while (remainingQuantity > 0 && (stackableSlot = findStackableSlot(player.inventory, itemId)) !== -1) {
                const spaceAvailable = maxStack - player.inventory[stackableSlot].quantity;
                const amountToAdd = Math.min(remainingQuantity, spaceAvailable);
                player.inventory[stackableSlot].quantity += amountToAdd;
                remainingQuantity -= amountToAdd;
            }

            // 2. Try adding to new slots in inventory
            let emptySlot;
            while (remainingQuantity > 0 && (emptySlot = findEmptySlot(player.inventory)) !== -1) {
                 const amountToAdd = Math.min(remainingQuantity, maxStack);
                 if (emptySlot < player.inventory.length) { // Existing empty slot
                     player.inventory[emptySlot] = { id: itemId, quantity: amountToAdd };
                 } else { // Append to inventory array
                     player.inventory.push({ id: itemId, quantity: amountToAdd });
                 }
                remainingQuantity -= amountToAdd;
            }

             if (remainingQuantity > 0) {
                 showMessage(`Inventory full, couldn't pick up ${remainingQuantity} ${itemData.name}`, 3000);
             } else {
                 showMessage(`Added ${quantity} ${itemData.name}`, 1500);
             }

             if (showInventory) updateInventoryUI(); // Update UI if open
             updateQuickbarFromInventory(); // Ensure quickbar reflects changes if needed

             return remainingQuantity;
         }


         function addItemToQuickbar(itemId, quantity, specificSlot = -1) {
             const itemData = items[itemId];
             if (!itemData) return quantity;
             const maxStack = itemData.stack || 1;
             let remainingQuantity = quantity;

             // Helper to add/stack in a specific quickbar slot
             const addToSlot = (slotIndex) => {
                 if (remainingQuantity <= 0) return;

                 if (!player.quickbar[slotIndex]) { // Empty slot
                     const amountToAdd = Math.min(remainingQuantity, maxStack);
                     player.quickbar[slotIndex] = { id: itemId, quantity: amountToAdd };
                     remainingQuantity -= amountToAdd;
                 } else if (player.quickbar[slotIndex].id === itemId && player.quickbar[slotIndex].quantity < maxStack) { // Stackable slot
                     const spaceAvailable = maxStack - player.quickbar[slotIndex].quantity;
                     const amountToAdd = Math.min(remainingQuantity, spaceAvailable);
                     player.quickbar[slotIndex].quantity += amountToAdd;
                     remainingQuantity -= amountToAdd;
                 }
             };

             // If a specific slot is requested (e.g., moving from inventory)
             if (specificSlot >= 0 && specificSlot < player.quickbar.length) {
                 addToSlot(specificSlot);
             }

             // If quantity remains, try stacking onto existing matching items
             if (remainingQuantity > 0) {
                 for (let i = 0; i < player.quickbar.length; i++) {
                      if (i !== specificSlot) { // Don't re-check the specific slot if it was used
                         addToSlot(i);
                         if (remainingQuantity <= 0) break;
                      }
                 }
             }

              // If quantity still remains, try finding any empty slot
              if (remainingQuantity > 0) {
                  for (let i = 0; i < player.quickbar.length; i++) {
                      if (!player.quickbar[i] && i !== specificSlot) {
                          addToSlot(i);
                          if (remainingQuantity <= 0) break;
                      }
                  }
              }

             updateQuickbarDisplay();
             if (showInventory) updateInventoryUI();

             return remainingQuantity; // Return amount that couldn't be placed
         }


         // Simple function to ensure quickbar has *something* if possible
         function updateQuickbarFromInventory() {
            let changed = false;
             for(let i = 0; i < player.quickbar.length; i++) {
                 if(player.quickbar[i] === null) {
                     // Find first available item in inventory to put here
                     for(let j = 0; j < player.inventory.length; j++) {
                         if(player.inventory[j] !== null) {
                            // Check if this item is already present in another quickbar slot
                             let alreadyInQuickbar = false;
                             for (let k = 0; k < player.quickbar.length; k++) {
                                if (player.quickbar[k] && player.quickbar[k].id === player.inventory[j].id) {
                                    alreadyInQuickbar = true;
                                    break;
                                }
                             }

                            if (!alreadyInQuickbar) {
                                player.quickbar[i] = player.inventory[j];
                                player.inventory.splice(j, 1); // Remove from inventory
                                changed = true;
                                break; // Found an item for this slot, move to next quickbar slot
                            }
                         }
                     }
                 }
             }
              if (changed) {
                if (showInventory) updateInventoryUI();
                updateQuickbarDisplay();
              }
         }

         function countResources(resourceId) {
             let count = 0;
             // Check quickbar
             for (const item of player.quickbar) {
                 if (item && item.id === resourceId) {
                     count += item.quantity;
                 }
             }
             // Check inventory
             for (const item of player.inventory) {
                 if (item && item.id === resourceId) {
                     count += item.quantity;
                 }
             }
             return count;
         }

         function consumeResources(resourceId, quantity) {
            let remainingNeeded = quantity;

            // Consume from quickbar first
             for (let i = 0; i < player.quickbar.length && remainingNeeded > 0; i++) {
                 let item = player.quickbar[i];
                 if (item && item.id === resourceId) {
                     const amountToTake = Math.min(remainingNeeded, item.quantity);
                     item.quantity -= amountToTake;
                     remainingNeeded -= amountToTake;
                     if (item.quantity <= 0) {
                         player.quickbar[i] = null; // Remove item if depleted
                     }
                 }
             }

            // Consume from inventory next
             for (let i = 0; i < player.inventory.length && remainingNeeded > 0; i++) {
                 let item = player.inventory[i];
                 if (item && item.id === resourceId) {
                     const amountToTake = Math.min(remainingNeeded, item.quantity);
                     item.quantity -= amountToTake;
                     remainingNeeded -= amountToTake;
                     if (item.quantity <= 0) {
                          // Remove item if depleted (need to be careful with array indices)
                          player.inventory.splice(i, 1);
                          i--; // Adjust index after removal
                     }
                 }
             }
            return quantity - remainingNeeded; // Return amount successfully consumed
         }


         function craftItem(recipeId) {
             const recipe = recipes[recipeId];
             if (!recipe) {
                 showMessage("Unknown recipe.", 2000);
                 return;
             }

             // 1. Check if resources are available
             let canCraft = true;
             for (const required of recipe.requires) {
                 if (countResources(required.id) < required.quantity) {
                     canCraft = false;
                     showMessage(`Need ${required.quantity} ${items[required.id].name}.`, 2000);
                     break;
                 }
             }

             // 2. If resources available, consume them
             if (canCraft) {
                 for (const required of recipe.requires) {
                     consumeResources(required.id, required.quantity);
                 }

                 // 3. Add crafted item
                 const craftedItemId = recipe.yields.id;
                 const craftedQuantity = recipe.yields.quantity;

                 // Try adding to quickbar first
                 let remainingToAdd = addItemToQuickbar(craftedItemId, craftedQuantity);

                 // If quickbar is full or couldn't take all, add to inventory
                 if (remainingToAdd > 0) {
                    remainingToAdd = addItemToInventory(craftedItemId, remainingToAdd);
                 }

                 // Check if item was successfully added somewhere
                 if (remainingToAdd < craftedQuantity) {
                     showMessage(`Crafted ${items[craftedItemId].name}.`, 2000);
                 } else {
                      // This case should ideally not happen if inventory isn't strictly limited in size
                      // but good to handle. We should technically give resources back if item cant be placed.
                      showMessage(`Crafted ${items[craftedItemId].name}, but couldn't place it!`, 3000);
                       // TODO: Add logic to return consumed resources if crafting fails at the end
                 }


                 if (showInventory) updateInventoryUI();
                 updateQuickbarDisplay();

             } else {
                 // Message already shown during check
                 // showMessage("Not enough resources to craft.", 2000);
             }
         }


        // --- UI Update Functions ---

        function updateInventoryUI() {
            if (!showInventory) return;

            inventoryQuickbarGrid.innerHTML = '';
            inventoryMainGrid.innerHTML = '';

            // Populate Quickbar in Inventory View
             for (let i = 0; i < player.quickbar.length; i++) {
                const slot = document.createElement('div');
                slot.classList.add('slot'); // Use inventory slot styling
                 slot.dataset.index = i; // Store index for click handling
                 const item = player.quickbar[i];
                 if(item) {
                     slot.innerHTML = `<span class="item-name">${items[item.id].name}</span><span class="item-count">${item.quantity}</span>`;
                     // Add tooltip or background image later if needed
                 } else {
                     slot.innerHTML = `[${i+1}]`; // Show slot number if empty
                 }
                 inventoryQuickbarGrid.appendChild(slot);
             }

             // Populate Main Inventory Grid
            const maxInvSlotsRender = 40; // Limit display slots for performance/layout
            for (let i = 0; i < Math.max(player.inventory.length, maxInvSlotsRender); i++) {
                 const slot = document.createElement('div');
                 slot.classList.add('slot');
                 slot.dataset.index = i; // Store index for click handling
                  const item = player.inventory[i];
                  if (item) {
                      slot.innerHTML = `<span class="item-name">${items[item.id].name}</span><span class="item-count">${item.quantity}</span>`;
                  } else if (i < player.inventory.length) {
                     // This case should ideally not happen if we splice nulls correctly
                     slot.innerHTML = `(Null?)`;
                  }
                  else {
                      // Empty slot placeholder
                      slot.innerHTML = ``;
                  }

                  // Add crafting button if it's a known recipe (simple demo)
                  if(item && recipes[item.id]) {
                      const craftButton = document.createElement('button');
                      craftButton.textContent = 'Craft';
                      craftButton.style.fontSize = '8px';
                      craftButton.style.marginTop = '3px';
                      craftButton.onclick = (e) => {
                          e.stopPropagation(); // Prevent triggering shift+click move
                          craftItem(item.id);
                      };
                      slot.appendChild(craftButton);
                  }
                  // Add simple craft buttons for basic recipes always visible in inventory
                 if (i === maxInvSlotsRender - 1 && recipes['rope']) { // Example: Add Rope craft button to last slot
                     slot.innerHTML += `<button onclick="craftItem('rope')" title="Requires 5 Fiber">Craft Rope</button>`;
                 }
                 if (i === maxInvSlotsRender - 2 && recipes['axe']) {
                      slot.innerHTML += `<button onclick="craftItem('axe')" title="Req Wood, Stone, Rope">Craft Axe</button>`;
                 }


                 inventoryMainGrid.appendChild(slot);
            }
         }

         function updateQuickbarDisplay() {
             quickbarDisplay.innerHTML = ''; // Clear current quickbar
             for (let i = 0; i < player.quickbar.length; i++) {
                 const qSlot = document.createElement('div');
                 qSlot.classList.add('q-slot');
                  if (i === player.selectedQuickSlot) {
                      qSlot.classList.add('selected');
                  }
                 const item = player.quickbar[i];
                 if (item) {
                      qSlot.innerHTML = `<span class="item-name">${items[item.id].name}</span><span class="item-count">${item.quantity}</span>`;
                      // TODO: Add item icons later using canvas drawing or data URIs if needed
                 } else {
                      qSlot.innerHTML = `${i + 1}`; // Show number if empty
                 }
                 quickbarDisplay.appendChild(qSlot);
             }
         }

         let messageTimeout = null;
         function showMessage(text, duration = 3000) {
             messageDisplay.textContent = text;
             messageDisplay.style.display = 'block';

             if (messageTimeout) {
                 clearTimeout(messageTimeout);
             }
             messageTimeout = setTimeout(() => {
                 messageDisplay.style.display = 'none';
                 messageTimeout = null;
             }, duration);
         }


        // --- Utility ---
        window.addEventListener('resize', () => {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            canvas.width = screenWidth;
            canvas.height = screenHeight;
            // No need to re-render immediately, game loop will handle it
        });

        // --- Start Check ---
        // Allow starting even if settings aren't changed
        if (!gameRunning && startScreen.style.display !== 'none') {
            console.log("Ready to start. Click the button!");
        }


    </script>
</body>
</html>
