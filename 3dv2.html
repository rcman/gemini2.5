<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic 3D Survival (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #333; color: white; }
        canvas { display: block; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex; /* Use flexbox */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        #instructions {
            width: 50%;
            /* height: 50%; */ /* Allow height to adjust */
            max-width: 400px;
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center content inside */
            align-items: center; /* Center content inside */
            text-align: center;
            font-size: 14px;
            cursor: pointer;
            background-color: rgba(50, 50, 50, 0.8);
            border-radius: 10px;
            padding: 20px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* So it doesn't interfere with clicks */
        }
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #quick-bar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
        }
        .quick-slot {
            width: 50px;
            height: 50px;
            border: 2px solid grey;
            background-color: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            position: relative; /* For quantity display */
            color: white; /* Ensure text is visible */
            overflow: hidden; /* Prevent text overflow */
        }
        .quick-slot.active {
            border-color: white;
        }
        .slot-item {
             /* Basic representation */
            width: 100%; /* Fill the slot */
            height: 100%; /* Fill the slot */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 10px;
            overflow: hidden;
            color: black; /* Default text color for items */
            background-color: lightgrey; /* Default background */
            line-height: 1.2; /* Adjust line height for small text */
            padding: 2px; /* Add padding */
            box-sizing: border-box; /* Include padding in size */
        }
         .slot-quantity {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 1px 3px;
            border-radius: 2px;
        }

        #inventory, #build-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            max-width: 90vw; /* Ensure it fits on smaller screens */
            background-color: rgba(50, 50, 50, 0.9);
            border: 2px solid grey;
            border-radius: 10px;
            padding: 20px;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            z-index: 10; /* Make sure menus are on top */
        }
         #inventory h2, #build-menu h2 {
            margin-top: 0;
         }
        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 5px;
            width: 100%;
            max-height: 250px; /* Allow scrolling if needed */
            overflow-y: auto;
            margin-bottom: 10px;
        }
        .inventory-slot {
             width: 50px; /* Fixed size for grid */
             height: 50px;
             border: 1px solid dimgrey;
             background-color: rgba(0,0,0,0.4);
             position: relative; /* For quantity */
             display: flex; /* To center item if needed */
             justify-content: center;
             align-items: center;
             overflow: hidden; /* Ensure content fits */
        }
        #build-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            align-items: center; /* Center buttons */
            max-height: 250px; /* Allow scrolling */
            overflow-y: auto;
            margin-bottom: 10px;
        }
        #build-options button {
            padding: 8px 15px;
            background-color: #444;
            border: 1px solid grey;
            color: white;
            cursor: pointer;
            width: 90%; /* Make buttons slightly narrower */
            font-size: 12px;
        }
         #build-options button:hover {
             background-color: #555;
         }
        #interaction-prompt {
            position: absolute;
            top: 60%; /* Below crosshair */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            display: none; /* Hidden by default */
            z-index: 5;
        }
         #message-area {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 0, 0, 0.7); /* Red for errors/warnings */
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            display: none; /* Hidden by default */
            text-align: center;
            z-index: 20; /* Highest priority */
            font-size: 14px;
         }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>Basic Survival Game</h1>
            <p>Move: WASD | Jump: SPACE | Look: MOUSE</p>
            <p>Interact/Harvest/Use: E or Left Mouse</p>
            <p>Inventory: I | Build Menu: B</p>
            <p>Select Quick Slot: 1-5</p>
            <p>(Click to start)</p>
        </div>
    </div>

    <div id="crosshair">+</div>

    <div class="hud">
        <div>Health: <span id="health">100</span></div>
        <div>Hunger: <span id="hunger">100</span></div>
        <div>Thirst: <span id="thirst">100</span></div>
    </div>

    <div id="quick-bar">
        <div class="quick-slot" data-slot="0"></div>
        <div class="quick-slot" data-slot="1"></div>
        <div class="quick-slot" data-slot="2"></div>
        <div class="quick-slot" data-slot="3"></div>
        <div class="quick-slot" data-slot="4"></div>
    </div>

    <div id="inventory">
        <h2>Inventory</h2>
        <div id="inventory-grid">
            <!-- Inventory slots will be added dynamically by JS -->
        </div>
        <p style="font-size: 12px; margin-top: 10px;">Press 'I' or 'ESC' to close</p>
    </div>

    <div id="build-menu">
        <h2>Build Menu</h2>
        <div id="build-options">
             <!-- Recipes updated slightly for example -->
             <button data-item="axe_basic">Axe (Wood: 3, Stone: 2)</button>
             <button data-item="pickaxe_basic">Pickaxe (Wood: 3, Stone: 3)</button>
             <button data-item="campfire">Campfire (Wood: 5, Stone: 5)</button>
             <button data-item="foundation">Foundation (Wood: 20)</button>
             <button data-item="wall">Wall (Wood: 15)</button>
             <button data-item="wall_window">Wall w/ Window (Wood: 12)</button>
             <button data-item="wall_doorway">Wall w/ Doorway (Wood: 10)</button>
             <button data-item="door">Door (Wood: 8)</button>
             <button data-item="roof">Roof (Wood: 15)</button>
             <!-- TODO: Add crafting table, forge buttons -->
        </div>
         <p style="font-size: 12px; margin-top: 10px;">Press 'B' or 'ESC' to close</p>
    </div>

    <div id="interaction-prompt"></div>
    <div id="message-area"></div>

    <!-- IMPORTANT: Using HTTP CDN as requested. This might fail. HTTPS is standard. -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- PointerLockControls Included -->
    <script>
        // PointerLockControls definition (adapted from Three.js examples, r128)
        var PointerLockControls = function ( camera, domElement ) {
            if ( domElement === undefined ) {
                console.warn( 'THREE.PointerLockControls: The second parameter "domElement" is now mandatory.' );
                domElement = document.body;
            }
            this.domElement = domElement;
            this.isLocked = false;
            this.minPolarAngle = 0; this.maxPolarAngle = Math.PI;
            var scope = this;
            var changeEvent = { type: 'change' }; var lockEvent = { type: 'lock' }; var unlockEvent = { type: 'unlock' };
            var euler = new THREE.Euler( 0, 0, 0, 'YXZ' ); var PI_2 = Math.PI / 2; var vec = new THREE.Vector3();
            function onMouseMove( event ) {
                if ( scope.isLocked === false ) return;
                var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                euler.setFromQuaternion( camera.quaternion );
                euler.y -= movementX * 0.002; euler.x -= movementY * 0.002;
                euler.x = Math.max( PI_2 - scope.maxPolarAngle, Math.min( PI_2 - scope.minPolarAngle, euler.x ) );
                camera.quaternion.setFromEuler( euler ); scope.dispatchEvent( changeEvent );
            }
            function onPointerlockChange() {
                if ( document.pointerLockElement === scope.domElement ) {
                    scope.dispatchEvent( lockEvent ); scope.isLocked = true;
                } else {
                    scope.dispatchEvent( unlockEvent ); scope.isLocked = false;
                }
            }
            function onPointerlockError() { console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' ); }
            this.connect = function () {
                document.addEventListener( 'mousemove', onMouseMove, false );
                document.addEventListener( 'pointerlockchange', onPointerlockChange, false );
                document.addEventListener( 'pointerlockerror', onPointerlockError, false );
            };
            this.disconnect = function () {
                document.removeEventListener( 'mousemove', onMouseMove, false );
                document.removeEventListener( 'pointerlockchange', onPointerlockChange, false );
                document.removeEventListener( 'pointerlockerror', onPointerlockError, false );
            };
            this.dispose = function () { this.disconnect(); };
            this.getObject = function () { return camera; };
            this.getDirection = function () { var direction = new THREE.Vector3( 0, 0, - 1 ); return function ( v ) { return v.copy( direction ).applyQuaternion( camera.quaternion ); }; }();
            this.moveForward = function ( distance ) { vec.setFromMatrixColumn( camera.matrix, 0 ); vec.crossVectors( camera.up, vec ); camera.position.addScaledVector( vec, distance ); };
            this.moveRight = function ( distance ) { vec.setFromMatrixColumn( camera.matrix, 0 ); camera.position.addScaledVector( vec, distance ); };
            this.lock = function () { this.domElement.requestPointerLock(); };
            this.unlock = function () { document.exitPointerLock(); };
            this.connect();
        };
        PointerLockControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        PointerLockControls.prototype.constructor = PointerLockControls;
    </script>

    <script>
        // --- Ensure Three.js is loaded ---
        if (typeof THREE === 'undefined') {
            alert('Error: Three.js library failed to load. Check the console (F12) and the HTTP link used.');
            document.getElementById('instructions').innerHTML = '<h1>Error</h1><p>Three.js failed to load.<br>This might be due to using an HTTP link which is often blocked or redirected.<br>Check the browser console (F12) for details.</p>';
        } else {
            // --- Game Setup ---
            let scene, camera, renderer, controls;
            let clock = new THREE.Clock();
            let raycaster = new THREE.Raycaster();
            let mouse = new THREE.Vector2(); // Not used for PointerLock look, but maybe for UI later

            const objects = []; // Store interactable objects (trees, rocks, etc.)
            let moveForward = false;
            let moveBackward = false;
            let moveLeft = false;
            let moveRight = false;
            let canJump = false; // Ground check needed for true jump
            let playerVelocity = new THREE.Vector3();
            const playerHeight = 1.8; // Apparent height (camera pos)
            const playerFeetOffset = 0.9; // How far below camera pos the 'feet' are for ground check
            const moveSpeed = 29.0;
            const jumpVelocity = 7.0;
            const gravity = 15.0;

            // --- UI State Variables --- <<<<<<< MOVED HERE (FIX)
            let isInventoryOpen = false;
            let isBuildMenuOpen = false;
            let currentInteractable = null;

            // --- Player State ---
            const player = {
                health: 100,
                hunger: 100,
                thirst: 100,
                inventory: [], // Array of item objects { id, name, quantity, ... }
                quickBar: new Array(5).fill(null), // Represents quick slots 0-4
                inventorySize: 20, // Max slots in inventory grid
                currentQuickSlot: 0,
                // Starting items
                startItems: [
                    { id: 'axe_basic', name: 'Basic Axe', quantity: 1, type: 'tool' },
                    { id: 'pickaxe_basic', name: 'Basic Pickaxe', quantity: 1, type: 'tool' },
                    { id: 'knife_basic', name: 'Basic Knife', quantity: 1, type: 'tool' },
                    { id: 'canteen_empty', name: 'Canteen', quantity: 1, type: 'container', contains: null, capacity: 1 }
                ]
            };

            // --- UI Elements ---
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            const healthElement = document.getElementById('health');
            const hungerElement = document.getElementById('hunger');
            const thirstElement = document.getElementById('thirst');
            const quickBarSlots = document.querySelectorAll('.quick-slot');
            const inventoryPanel = document.getElementById('inventory');
            const inventoryGrid = document.getElementById('inventory-grid');
            const buildMenuPanel = document.getElementById('build-menu');
            const buildOptions = document.getElementById('build-options');
            const interactionPrompt = document.getElementById('interaction-prompt');
            const messageArea = document.getElementById('message-area');
            let messageTimeout = null; // To clear previous message timeouts

            // --- Game Data ---
            const itemData = {
                'wood': { name: 'Wood', stackSize: 50, type: 'resource' },
                'stone': { name: 'Stone', stackSize: 50, type: 'resource' },
                'scrap_metal': { name: 'Scrap Metal', stackSize: 30, type: 'resource' },
                'nails': { name: 'Nails', stackSize: 100, type: 'resource' },
                'raw_meat': { name: 'Raw Meat', stackSize: 10, type: 'food' },
                'cooked_meat': { name: 'Cooked Meat', stackSize: 10, type: 'food' },
                'leather': { name: 'Leather', stackSize: 20, type: 'resource' },
                'animal_fat': { name: 'Animal Fat', stackSize: 15, type: 'resource' },
                'dirty_water': { name: 'Dirty Water', stackSize: 1, type: 'water' },
                'clean_water': { name: 'Clean Water', stackSize: 1, type: 'water' },

                'axe_basic': { name: 'Basic Axe', stackSize: 1, type: 'tool', harvest: ['tree'] },
                'pickaxe_basic': { name: 'Basic Pickaxe', stackSize: 1, type: 'tool', harvest: ['rock'] },
                'knife_basic': { name: 'Basic Knife', stackSize: 1, type: 'tool', harvest: ['animal'] }, // Placeholder
                'canteen_empty': { name: 'Canteen', stackSize: 1, type: 'container', contains: null, capacity: 1 },
                'canteen_dirty': { name: 'Canteen (Dirty)', stackSize: 1, type: 'container', contains: 'dirty_water', capacity: 1 },
                'canteen_clean': { name: 'Canteen (Clean)', stackSize: 1, type: 'container', contains: 'clean_water', capacity: 1 },

                'campfire': { name: 'Campfire', stackSize: 1, type: 'placeable', interact: 'cook_ui' },
                'foundation': { name: 'Foundation', stackSize: 1, type: 'placeable', structure: true },
                'wall': { name: 'Wall', stackSize: 1, type: 'placeable', structure: true },
                'wall_window': { name: 'Wall w/ Window', stackSize: 1, type: 'placeable', structure: true },
                'wall_doorway': { name: 'Wall w/ Doorway', stackSize: 1, type: 'placeable', structure: true },
                'door': { name: 'Door', stackSize: 1, type: 'placeable', structure: true, interact: 'toggle_open' },
                'roof': { name: 'Roof', stackSize: 1, type: 'placeable', structure: true },
                // TODO: 'crafting_table', 'forge'
            };

            const recipes = {
                 'axe_basic': { 'wood': 3, 'stone': 2 },
                 'pickaxe_basic': { 'wood': 3, 'stone': 3 },
                 'campfire': { 'wood': 5, 'stone': 5 },
                 'foundation': { 'wood': 20 },
                 'wall': { 'wood': 15 },
                 'wall_window': { 'wood': 12 },
                 'wall_doorway': { 'wood': 10 },
                 'door': { 'wood': 8 },
                 'roof': { 'wood': 15 },
                 // TODO: Add recipes for crafting table, forge
            };

            // --- Initialization ---
            init();
            animate(); // Start the loop only after successful init

            function init() {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb); // Sky blue
                scene.fog = new THREE.Fog(0x87ceeb, 50, 200); // Fog starts further away

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.y = playerHeight;

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(15, 30, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 100;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                scene.add(directionalLight);
                // const helper = new THREE.CameraHelper( directionalLight.shadow.camera ); scene.add( helper ); // Optional: visualize shadow camera

                // Controls
                controls = new PointerLockControls(camera, document.body);
                scene.add(controls.getObject());

                // Pointer lock events for instructions screen
                instructions.addEventListener('click', () => {
                    controls.lock();
                });
                controls.addEventListener('lock', () => {
                    instructions.style.display = 'none';
                    blocker.style.display = 'none';
                    if (isInventoryOpen) toggleInventory(); // Close UI if open
                    if (isBuildMenuOpen) toggleBuildMenu();
                });
                controls.addEventListener('unlock', () => {
                    blocker.style.display = 'flex';
                    // If a menu isn't forcing the blocker open, show instructions
                    if (!isInventoryOpen && !isBuildMenuOpen) {
                         instructions.innerHTML = '<h1>Paused</h1><p>(Click to resume)</p>';
                         instructions.style.display = 'flex';
                    } else {
                        // If a menu IS open, keep blocker but hide default instructions
                        instructions.style.display = 'none';
                    }
                });

                // Input Listeners
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.addEventListener('mousedown', onMouseDown);
                window.addEventListener('resize', onWindowResize);

                // --- World Generation ---
                createGround();
                createWater();
                for (let i = 0; i < 100; i++) createTree(Math.random() * 300 - 150, Math.random() * 300 - 150);
                for (let i = 0; i < 80; i++) createRock(Math.random() * 300 - 150, Math.random() * 300 - 150);
                for (let i = 0; i < 15; i++) createBarrel(Math.random() * 250 - 125, Math.random() * 250 - 125);
                // TODO: Add buildings, scrap metal, animals...

                // --- Player Setup ---
                giveStartItems();
                updateQuickBarUI();
                updateInventoryUI(); // Safe to call now
                updateHUD();
                setActiveQuickSlot(0);
                setupBuildMenuActions();
            }

            // --- World Object Creation ---
            function createGround() {
                const groundGeometry = new THREE.PlaneGeometry(500, 500);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x3c602a, roughness: 0.9, metalness: 0.1 }); // More textured green
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                ground.userData = { type: 'ground' }; // For ground check raycast
                scene.add(ground);
                objects.push(ground); // Add ground for raycasting checks
            }

            function createWater() {
                 const waterGeometry = new THREE.PlaneGeometry(100, 100);
                 const waterMaterial = new THREE.MeshStandardMaterial({
                     color: 0x4682B4,
                     transparent: true,
                     opacity: 0.8,
                     roughness: 0.2,
                     metalness: 0.3
                 });
                 const water = new THREE.Mesh(waterGeometry, waterMaterial);
                 water.rotation.x = -Math.PI / 2;
                 water.position.set(150, -0.05, 0); // Slightly above ground to avoid z-fighting
                 water.userData = { type: 'water_source' };
                 scene.add(water);
                 objects.push(water);
            }

            function createTree(x, z) {
                const trunkHeight = Math.random() * 4 + 3;
                const trunkRadius = Math.random() * 0.3 + 0.2;
                const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6a4a3a, roughness: 0.8 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.castShadow = true;
                trunk.receiveShadow = true;

                const leavesHeight = trunkHeight * 1.0; // Make leaves overlap trunk more
                const leavesRadius = trunkRadius * (Math.random() * 2 + 4); // Wider range of leaf sizes
                const leavesGeo = new THREE.IcosahedronGeometry(leavesRadius, 0); // Low poly sphere
                const leavesMat = new THREE.MeshStandardMaterial({ color: 0x2a4f2a, roughness: 0.9 });
                const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                leaves.position.y = trunkHeight * 0.7; // Position leaves lower
                leaves.castShadow = true;
                leaves.receiveShadow = true; // Leaves receive shadows too

                const tree = new THREE.Group();
                tree.add(trunk);
                tree.add(leaves);
                tree.position.set(x, trunkHeight / 2, z); // Position group base at ground
                scene.add(tree);

                // Add userData to the trunk for interaction
                trunk.userData = { type: 'tree', health: 100, resource: 'wood', drops: { wood: 5 + Math.floor(Math.random() * 6) }, group: tree, mainMesh: trunk };
                objects.push(trunk);
            }

            function createRock(x, z) {
                const rockSize = Math.random() * 1 + 0.5;
                const rockGeo = new THREE.IcosahedronGeometry(rockSize, 0); // Low poly sphere
                const rockMat = new THREE.MeshStandardMaterial({ color: 0x777777, roughness: 0.7 });
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.position.set(x, rockSize * 0.5, z); // Position base on ground
                rock.castShadow = true;
                rock.receiveShadow = true;
                rock.userData = { type: 'rock', health: 150, resource: 'stone', drops: { stone: 3 + Math.floor(Math.random() * 4) }, mainMesh: rock };
                scene.add(rock);
                objects.push(rock);
            }

            function createBarrel(x, z) {
                 const barrelHeight = 1;
                 const barrelRadius = 0.4;
                 const barrelGeo = new THREE.CylinderGeometry(barrelRadius, barrelRadius, barrelHeight, 12);
                 const barrelMat = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.6, metalness: 0.2 }); // Sienna
                 const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                 barrel.position.set(x, barrelHeight / 2, z);
                 barrel.castShadow = true;
                 barrel.receiveShadow = true;
                 const possibleLoot = [
                     { id: 'scrap_metal', quantity: [2, 6] },
                     { id: 'nails', quantity: [5, 20] },
                     { id: 'raw_meat', quantity: [1, 1] }, // Maybe canned food?
                     { id: 'canteen_empty', quantity: [1, 1] },
                     { id: 'animal_fat', quantity: [1, 3] },
                 ];
                 barrel.userData = { type: 'barrel', looted: false, lootTable: possibleLoot, mainMesh: barrel };
                 scene.add(barrel);
                 objects.push(barrel);
            }

            // --- Player Actions ---
            function giveStartItems() {
                 player.startItems.forEach(itemInfo => {
                     addItemToInventory(itemInfo.id, itemInfo.quantity);
                 });
            }

            function getSelectedItem() {
                return player.quickBar[player.currentQuickSlot];
            }

            function setActiveQuickSlot(slotIndex) {
                slotIndex = Math.max(0, Math.min(quickBarSlots.length - 1, slotIndex));
                quickBarSlots[player.currentQuickSlot].classList.remove('active');
                player.currentQuickSlot = slotIndex;
                quickBarSlots[player.currentQuickSlot].classList.add('active');
                // console.log("Selected:", getSelectedItem()?.name || 'Empty');
            }

            function displayMessage(text, duration = 3000, isError = false) {
                if (messageTimeout) clearTimeout(messageTimeout); // Clear previous timeout
                messageArea.textContent = text;
                messageArea.style.backgroundColor = isError ? 'rgba(200, 0, 0, 0.8)' : 'rgba(0, 100, 0, 0.8)';
                messageArea.style.display = 'block';
                messageTimeout = setTimeout(() => {
                    messageArea.style.display = 'none';
                    messageTimeout = null;
                }, duration);
            }

            // --- Inventory Management ---
             function findFirstFreeQuickSlot() {
                 return player.quickBar.findIndex(slot => slot === null);
             }

             function findFirstFreeInventorySlotIndex() {
                 // A simple check based on array length vs max size
                 return player.inventory.length < player.inventorySize ? player.inventory.length : -1;
             }

             function findItemStack(itemId, checkQuickBar = true, checkInventory = true) {
                const baseItemInfo = itemData[itemId];
                if (!baseItemInfo) return null; // Item doesn't exist
                const stackSize = baseItemInfo.stackSize || 1;

                 if (checkQuickBar) {
                     for (let i = 0; i < player.quickBar.length; i++) {
                         const item = player.quickBar[i];
                         if (item && item.id === itemId && item.quantity < stackSize) {
                             return { location: 'quickbar', index: i, item: item };
                         }
                     }
                 }
                 if (checkInventory) {
                     for (let i = 0; i < player.inventory.length; i++) {
                         const item = player.inventory[i];
                         if (item && item.id === itemId && item.quantity < stackSize) {
                             return { location: 'inventory', index: i, item: item };
                         }
                     }
                 }
                 return null; // No stack found with space
             }

             function addItemToInventory(itemId, quantity) {
                 const baseItemInfo = itemData[itemId];
                 if (!baseItemInfo) {
                     console.error("Attempted to add unknown item:", itemId);
                     return false;
                 }

                 const stackSize = baseItemInfo.stackSize || 1;
                 let remainingQuantity = quantity;

                 // console.log(`Attempting to add ${quantity} of ${itemId}`);

                 // 1. Try stacking (Quick Bar first, then Inventory)
                 while (remainingQuantity > 0) {
                     const existingStack = findItemStack(itemId, true, true); // Check both
                     if (existingStack) {
                         const canAdd = stackSize - existingStack.item.quantity;
                         const amountToAdd = Math.min(remainingQuantity, canAdd);
                         existingStack.item.quantity += amountToAdd;
                         remainingQuantity -= amountToAdd;
                         // console.log(`Stacked ${amountToAdd} in ${existingStack.location} slot ${existingStack.index}`);
                     } else {
                         break; // No more stacks found anywhere
                     }
                 }

                // 2. Place remaining in new slots (Quick Bar first)
                 while (remainingQuantity > 0) {
                     const freeQuickSlot = findFirstFreeQuickSlot();
                     if (freeQuickSlot !== -1) {
                         const amountToAdd = Math.min(remainingQuantity, stackSize);
                         // Create a *copy* of the base item data + id/quantity
                         const newItem = { ...baseItemInfo, id: itemId, quantity: amountToAdd };
                         // Add specific container properties if needed
                         if(newItem.type === 'container') {
                            newItem.contains = baseItemInfo.contains !== undefined ? baseItemInfo.contains : null;
                            newItem.capacity = baseItemInfo.capacity || 1;
                         }
                         player.quickBar[freeQuickSlot] = newItem;
                         remainingQuantity -= amountToAdd;
                         // console.log(`Added ${amountToAdd} to new quickbar slot ${freeQuickSlot}`);
                     } else {
                         break; // No free quick slots
                     }
                 }

                 // 3. Place remaining in new Inventory slots
                 while (remainingQuantity > 0) {
                     const freeInvSlotIndex = findFirstFreeInventorySlotIndex();
                     if (freeInvSlotIndex !== -1) { // Checks capacity implicitly
                         const amountToAdd = Math.min(remainingQuantity, stackSize);
                         const newItem = { ...baseItemInfo, id: itemId, quantity: amountToAdd };
                          if(newItem.type === 'container') {
                             newItem.contains = baseItemInfo.contains !== undefined ? baseItemInfo.contains : null;
                             newItem.capacity = baseItemInfo.capacity || 1;
                          }
                         player.inventory.push(newItem); // Add to the end of the array
                         remainingQuantity -= amountToAdd;
                         // console.log(`Added ${amountToAdd} to new inventory slot`);
                     } else {
                         // Inventory full
                         if (remainingQuantity > 0) {
                            displayMessage(`Inventory full! ${remainingQuantity} ${baseItemInfo.name} lost.`, 4000, true);
                             console.warn("Inventory full, couldn't add remaining:", remainingQuantity, itemId);
                         }
                         break; // Exit loop, items are lost
                     }
                 }

                 updateQuickBarUI();
                 updateInventoryUI(); // Update UI after changes
                 return remainingQuantity <= 0; // Return true if all items were added
             }

            function getTotalResourceCount(itemId) {
                let count = 0;
                player.quickBar.forEach(item => { if (item && item.id === itemId) count += item.quantity; });
                player.inventory.forEach(item => { if (item && item.id === itemId) count += item.quantity; });
                return count;
            }

             function consumeResources(resourcesNeeded) {
                 // Check if enough resources exist first
                 for (const itemId in resourcesNeeded) {
                     const required = resourcesNeeded[itemId];
                     const available = getTotalResourceCount(itemId);
                     if (available < required) {
                         displayMessage(`Not enough ${itemData[itemId]?.name || itemId}! Need ${required}, have ${available}.`, 3000, true);
                         return false;
                     }
                 }

                 // If checks pass, consume items (prioritize quick bar, then inventory LIFO)
                 for (const itemId in resourcesNeeded) {
                     let remainingToConsume = resourcesNeeded[itemId];

                     // Consume from Quick Bar
                     for (let i = 0; i < player.quickBar.length && remainingToConsume > 0; i++) {
                         const item = player.quickBar[i];
                         if (item && item.id === itemId) {
                             const amountToTake = Math.min(remainingToConsume, item.quantity);
                             item.quantity -= amountToTake;
                             remainingToConsume -= amountToTake;
                             if (item.quantity <= 0) player.quickBar[i] = null;
                         }
                     }

                     // Consume from Inventory (Last-In, First-Out is often simpler)
                     for (let i = player.inventory.length - 1; i >= 0 && remainingToConsume > 0; i--) {
                         const item = player.inventory[i];
                         if (item && item.id === itemId) {
                             const amountToTake = Math.min(remainingToConsume, item.quantity);
                             item.quantity -= amountToTake;
                             remainingToConsume -= amountToTake;
                             if (item.quantity <= 0) player.inventory.splice(i, 1); // Remove item if depleted
                         }
                     }
                 }

                 updateQuickBarUI();
                 updateInventoryUI();
                 return true; // Resources consumed successfully
             }


            // --- UI Update Functions ---
            function updateHUD() {
                healthElement.textContent = player.health;
                hungerElement.textContent = player.hunger;
                thirstElement.textContent = player.thirst;
            }

            function updateQuickBarUI() {
                quickBarSlots.forEach((slotElement, index) => {
                    const item = player.quickBar[index];
                    slotElement.innerHTML = ''; // Clear previous content
                    if (item) {
                        const itemDiv = document.createElement('div');
                        itemDiv.classList.add('slot-item');
                        itemDiv.textContent = item.name; // Show full name if possible
                        itemDiv.title = `${item.name} (${item.quantity})`; // Tooltip

                         // Placeholder styling based on type
                         if(item.type === 'tool') itemDiv.style.backgroundColor = 'lightblue';
                         else if(item.type === 'resource') itemDiv.style.backgroundColor = 'sandybrown';
                         else if(item.type === 'food') itemDiv.style.backgroundColor = 'lightcoral';
                         else if(item.type === 'container') itemDiv.style.backgroundColor = 'lightgrey';
                         else if(item.type === 'placeable') itemDiv.style.backgroundColor = 'lightgreen';

                         slotElement.appendChild(itemDiv);

                        if ((itemData[item.id]?.stackSize || 1) > 1 && item.quantity > 1) {
                            const quantityDiv = document.createElement('div');
                            quantityDiv.classList.add('slot-quantity');
                            quantityDiv.textContent = item.quantity;
                            slotElement.appendChild(quantityDiv);
                        }
                    }
                });
            }

            function toggleInventory() {
                isInventoryOpen = !isInventoryOpen;
                inventoryPanel.style.display = isInventoryOpen ? 'flex' : 'none';
                blocker.style.display = isInventoryOpen || isBuildMenuOpen ? 'flex' : 'none'; // Show blocker if either menu is open

                if (isInventoryOpen) {
                     controls.unlock(); // Will trigger unlock listener
                     instructions.style.display = 'none'; // Hide pause message
                     updateInventoryUI(); // Refresh display when opened
                     if(isBuildMenuOpen) toggleBuildMenu(); // Close other menu
                } else {
                    // If closing, and build menu also closed, try re-locking pointer
                    if (!isBuildMenuOpen) {
                       // Delay lock slightly to prevent immediate re-unlock if Escape was pressed
                       setTimeout(() => { if (!isInventoryOpen && !isBuildMenuOpen) controls.lock(); }, 50);
                    }
                }
            }

            function updateInventoryUI() {
                 // This check is safe now because isInventoryOpen is declared globally
                 if (!isInventoryOpen) return;

                 inventoryGrid.innerHTML = ''; // Clear existing slots
                 player.inventory.forEach((item, index) => {
                     const slotElement = document.createElement('div');
                     slotElement.classList.add('inventory-slot');
                     slotElement.title = `${item.name} (${item.quantity})`;

                     const itemDiv = document.createElement('div');
                     itemDiv.classList.add('slot-item');
                     itemDiv.textContent = item.name;

                     if(item.type === 'tool') itemDiv.style.backgroundColor = 'lightblue';
                     else if(item.type === 'resource') itemDiv.style.backgroundColor = 'sandybrown';
                     else if(item.type === 'food') itemDiv.style.backgroundColor = 'lightcoral';
                     else if(item.type === 'container') itemDiv.style.backgroundColor = 'lightgrey';
                     else if(item.type === 'placeable') itemDiv.style.backgroundColor = 'lightgreen';

                     slotElement.appendChild(itemDiv);

                     if ((itemData[item.id]?.stackSize || 1) > 1 && item.quantity > 1) {
                         const quantityDiv = document.createElement('div');
                         quantityDiv.classList.add('slot-quantity');
                         quantityDiv.textContent = item.quantity;
                         slotElement.appendChild(quantityDiv);
                     }
                     inventoryGrid.appendChild(slotElement);
                 });

                 // Fill remaining space with empty slots
                 const emptySlotsCount = player.inventorySize - player.inventory.length;
                 for (let i = 0; i < emptySlotsCount; i++) {
                     const slotElement = document.createElement('div');
                     slotElement.classList.add('inventory-slot');
                     inventoryGrid.appendChild(slotElement);
                 }
            }

             function toggleBuildMenu() {
                 isBuildMenuOpen = !isBuildMenuOpen;
                 buildMenuPanel.style.display = isBuildMenuOpen ? 'flex' : 'none';
                 blocker.style.display = isInventoryOpen || isBuildMenuOpen ? 'flex' : 'none'; // Show blocker if either menu is open

                  if (isBuildMenuOpen) {
                     controls.unlock();
                     instructions.style.display = 'none';
                     if(isInventoryOpen) toggleInventory(); // Close other menu
                 } else {
                      // If closing, and inventory also closed, try re-locking pointer
                      if (!isInventoryOpen) {
                          setTimeout(() => { if (!isInventoryOpen && !isBuildMenuOpen) controls.lock(); }, 50);
                      }
                 }
             }

             function setupBuildMenuActions() {
                 buildOptions.querySelectorAll('button').forEach(button => {
                     button.addEventListener('click', () => {
                         const itemId = button.dataset.item;
                         if (recipes[itemId]) {
                             attemptCraft(itemId);
                         } else {
                             displayMessage(`Recipe for ${itemData[itemId]?.name || itemId} not found.`, 3000, true);
                             console.warn("Recipe missing for button:", itemId);
                         }
                     });
                 });
             }

             function attemptCraft(itemId) {
                 const recipe = recipes[itemId];
                 if (!recipe) return;

                 // console.log(`Attempting to craft: ${itemId}`);

                 if (consumeResources(recipe)) {
                     if (addItemToInventory(itemId, 1)) {
                          displayMessage(`Crafted ${itemData[itemId]?.name || itemId}!`, 2000);
                          // Maybe close menu after craft?
                          // toggleBuildMenu();
                     } else {
                         // This case means inventory was full *after* consuming resources
                         // Ideally, return resources, but that's complex. Log error for now.
                         displayMessage(`Crafted ${itemData[itemId]?.name || itemId}, but inventory was full! Item lost.`, 4000, true);
                         console.error("Inventory full after crafting, resources consumed but item lost:", itemId);
                     }
                 }
                 // consumeResources shows "not enough" message if it fails
             }

             // --- Interaction ---
             function checkInteraction() {
                 if (!controls.isLocked) {
                    hideInteractionPrompt();
                    currentInteractable = null; // Clear target if not locked
                     return;
                 }

                 raycaster.setFromCamera({ x: 0, y: 0 }, camera); // Center of screen
                 const potentialTargets = objects.filter(o => o.userData.type && o.userData.type !== 'ground'); // Filter interactables
                 const intersects = raycaster.intersectObjects(potentialTargets, false); // Use the filtered list

                 let foundInteractable = false;
                 if (intersects.length > 0) {
                     const intersection = intersects[0];
                     // Make sure we hit the intended mesh (e.g., trunk, not leaves accidentally)
                     const object = intersection.object.userData.mainMesh || intersection.object; // Use mainMesh if defined
                     const distance = intersection.distance;

                     if (distance < 3.5 && object.userData.type) { // Increased range slightly
                         if (currentInteractable !== object) { // Only update if target changes
                            currentInteractable = object;
                            showInteractionPrompt(object);
                         }
                         foundInteractable = true;
                     }
                 }

                 if (!foundInteractable && currentInteractable) {
                     // Looking away from the previous target
                     hideInteractionPrompt();
                     currentInteractable = null;
                 }
             }

            function showInteractionPrompt(object) {
                let text = '';
                const data = object.userData;
                const selectedItem = getSelectedItem();

                switch(data.type) {
                    case 'tree':
                        text = `[E] Harvest Tree ${selectedItem?.id.includes('axe') ? `(HP: ${data.health})` : '(Need Axe)'}`;
                        break;
                    case 'rock':
                         text = `[E] Harvest Rock ${selectedItem?.id.includes('pickaxe') ? `(HP: ${data.health})` : '(Need Pickaxe)'}`;
                        break;
                    case 'barrel':
                        text = data.looted ? 'Barrel (Empty)' : '[E] Loot Barrel';
                        break;
                    case 'water_source':
                         // Check if player has *any* empty canteen
                         const hasEmptyCanteen = [...player.quickBar, ...player.inventory].some(item => item?.id === 'canteen_empty');
                         text = hasEmptyCanteen ? `[E] Collect Water` : 'Need Empty Canteen';
                         break;
                    // TODO: Add cases for placed objects (campfire, door)
                    default:
                        text = '[E] Interact';
                }
                interactionPrompt.textContent = text;
                interactionPrompt.style.display = 'block';
            }

            function hideInteractionPrompt() {
                interactionPrompt.style.display = 'none';
            }

            function performInteraction() {
                 if (!currentInteractable || !controls.isLocked) return;

                 const data = currentInteractable.userData;
                 const selectedItem = getSelectedItem();
                 const interactionObject = currentInteractable; // Cache it in case it gets destroyed

                 // console.log("Interacting with:", data.type);

                 switch(data.type) {
                     case 'tree':
                         if (selectedItem && itemData[selectedItem.id]?.harvest?.includes('tree')) {
                            data.health -= 25; // Damage amount
                            // displayMessage(`Hit tree (-25). Health: ${data.health}`, 1500);
                            showInteractionPrompt(interactionObject); // Update health in prompt
                            if (data.health <= 0) {
                                displayMessage(`Harvested Tree!`, 2000);
                                for (const resourceId in data.drops) {
                                    addItemToInventory(resourceId, data.drops[resourceId]);
                                }
                                scene.remove(data.group); // Remove the whole group
                                const index = objects.findIndex(o => o === interactionObject);
                                if (index > -1) objects.splice(index, 1);
                                currentInteractable = null;
                                hideInteractionPrompt();
                            }
                        } else {
                            displayMessage("Need an axe to harvest trees.", 2000, true);
                        }
                        break;
                     case 'rock':
                         if (selectedItem && itemData[selectedItem.id]?.harvest?.includes('rock')) {
                             data.health -= 20;
                             // displayMessage(`Hit rock (-20). Health: ${data.health}`, 1500);
                             showInteractionPrompt(interactionObject); // Update health in prompt
                              if (data.health <= 0) {
                                 displayMessage(`Harvested Rock!`, 2000);
                                 for (const resourceId in data.drops) {
                                     addItemToInventory(resourceId, data.drops[resourceId]);
                                 }
                                 scene.remove(interactionObject);
                                 const index = objects.findIndex(o => o === interactionObject);
                                 if (index > -1) objects.splice(index, 1);
                                 currentInteractable = null;
                                 hideInteractionPrompt();
                             }
                         } else {
                             displayMessage("Need a pickaxe to harvest rocks.", 2000, true);
                         }
                         break;
                    case 'barrel':
                        if (!data.looted) {
                            data.looted = true;
                            // displayMessage("Looted barrel!", 1500);
                            let lootGained = false;
                            const lootTable = data.lootTable || [];
                            const numItemsToDrop = Math.floor(Math.random() * 2) + 1; // 1 or 2 items

                            for(let i=0; i < numItemsToDrop; i++){
                                if(lootTable.length > 0){
                                    // Pick random item type from table
                                    const lootEntryIndex = Math.floor(Math.random() * lootTable.length);
                                    const chosenLootInfo = lootTable[lootEntryIndex];
                                    // Determine quantity
                                    const quantity = Math.floor(Math.random() * (chosenLootInfo.quantity[1] - chosenLootInfo.quantity[0] + 1)) + chosenLootInfo.quantity[0];
                                    if (addItemToInventory(chosenLootInfo.id, quantity)) {
                                        displayMessage(`Found ${quantity} ${itemData[chosenLootInfo.id]?.name || chosenLootInfo.id}!`, 2500);
                                        lootGained = true;
                                    }
                                    // Optional: Remove looted item type from table for this barrel instance?
                                    // lootTable.splice(lootEntryIndex, 1);
                                }
                            }
                            if (!lootGained) displayMessage("Barrel seems empty...", 1500);
                            showInteractionPrompt(interactionObject); // Update prompt text
                        } else {
                            displayMessage("Barrel is empty.", 1500);
                        }
                         break;
                     case 'water_source':
                         // Find the *first* empty canteen (prioritize quick bar)
                         let canteenSlot = null;
                         let canteenIndex = -1;
                         let canteenLocation = null;

                         for(let i=0; i < player.quickBar.length; i++){
                             if(player.quickBar[i]?.id === 'canteen_empty'){
                                 canteenSlot = player.quickBar[i];
                                 canteenIndex = i;
                                 canteenLocation = 'quickbar';
                                 break;
                             }
                         }
                         if(!canteenSlot){
                             for(let i=0; i < player.inventory.length; i++){
                                 if(player.inventory[i]?.id === 'canteen_empty'){
                                     canteenSlot = player.inventory[i];
                                     canteenIndex = i;
                                     canteenLocation = 'inventory';
                                     break;
                                 }
                             }
                         }

                         if(canteenSlot){
                            // "Transform" the item by replacing it with the dirty version
                            const dirtyCanteenData = itemData['canteen_dirty'];
                            const newCanteen = { ...dirtyCanteenData, id: 'canteen_dirty', quantity: 1 }; // Create new instance

                            if(canteenLocation === 'quickbar') {
                                player.quickBar[canteenIndex] = newCanteen;
                                updateQuickBarUI();
                            } else if (canteenLocation === 'inventory') {
                                player.inventory[canteenIndex] = newCanteen;
                                updateInventoryUI();
                            }
                            displayMessage('Filled canteen with dirty water. Boil it!', 3000);
                         } else {
                             displayMessage("Need an empty canteen to collect water.", 2000, true);
                         }
                         // Update prompt in case all canteens are now full
                         showInteractionPrompt(interactionObject);
                         break;
                 }
             }

            // --- Event Handlers ---
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function onKeyDown(event) {
                 // Allow menu toggle keys even when not locked
                 if (event.key.toLowerCase() === 'i') { toggleInventory(); return; }
                 if (event.key.toLowerCase() === 'b') { toggleBuildMenu(); return; }
                 if (event.key === 'Escape') {
                     if (isInventoryOpen) toggleInventory();
                     else if (isBuildMenuOpen) toggleBuildMenu();
                     // else controls.unlock(); // PointerLockControls handles Esc for unlocking automatically
                     return;
                 }

                 // Only handle movement/action keys if locked
                 if (!controls.isLocked) return;

                switch (event.key.toLowerCase()) {
                    case 'w': moveForward = true; break;
                    case 'a': moveLeft = true; break;
                    case 's': moveBackward = true; break;
                    case 'd': moveRight = true; break;
                    case ' ': if (canJump) playerVelocity.y += jumpVelocity; canJump = false; break;
                    case 'e': performInteraction(); break;
                    // Quick slot selection
                    case '1': setActiveQuickSlot(0); break;
                    case '2': setActiveQuickSlot(1); break;
                    case '3': setActiveQuickSlot(2); break;
                    case '4': setActiveQuickSlot(3); break;
                    case '5': setActiveQuickSlot(4); break;
                }
            }

            function onKeyUp(event) {
                // No need to check if locked for stopping movement
                switch (event.key.toLowerCase()) {
                    case 'w': moveForward = false; break;
                    case 'a': moveLeft = false; break;
                    case 's': moveBackward = false; break;
                    case 'd': moveRight = false; break;
                }
            }

            function onMouseDown(event) {
                 if (!controls.isLocked) return;
                 if (event.button === 0) { // Left Mouse Button
                     performInteraction(); // Map left-click to primary interaction
                 }
                 // else if (event.button === 2) { // Right Mouse Button - Placeholder }
             }

            // --- Game Loop ---
            function animate() {
                requestAnimationFrame(animate);
                const delta = Math.min(0.05, clock.getDelta()); // Cap delta to prevent physics glitches

                if (controls.isLocked) {
                    playerVelocity.x -= playerVelocity.x * 10.0 * delta; // Damping/friction
                    playerVelocity.z -= playerVelocity.z * 10.0 * delta;

                    const forwardDirection = new THREE.Vector3();
                    camera.getWorldDirection(forwardDirection);
                    forwardDirection.y = 0; // Project onto XZ plane
                    forwardDirection.normalize();

                    const rightDirection = new THREE.Vector3();
                    rightDirection.crossVectors(camera.up, forwardDirection).normalize(); // Get right vector

                    if (moveForward) playerVelocity.addScaledVector(forwardDirection, moveSpeed * delta);
                    if (moveBackward) playerVelocity.addScaledVector(forwardDirection, -moveSpeed * delta);
                    if (moveLeft) playerVelocity.addScaledVector(rightDirection, -moveSpeed * delta); // Negate right for left
                    if (moveRight) playerVelocity.addScaledVector(rightDirection, moveSpeed * delta);

                    // --- Ground Check ---
                    let isOnGround = false;
                    const feetPosition = controls.getObject().position.clone();
                    feetPosition.y -= playerFeetOffset; // Check from slightly below camera
                    const downRay = new THREE.Raycaster(feetPosition, new THREE.Vector3(0, -1, 0), 0, 0.2); // Short ray down
                    const groundIntersects = downRay.intersectObjects(objects.filter(o => o.userData.type === 'ground' || o.userData.structure), false); // Check ground & structures

                    if (groundIntersects.length > 0) {
                         isOnGround = true;
                         playerVelocity.y = Math.max(0, playerVelocity.y); // Stop falling
                         canJump = true;
                    } else {
                        playerVelocity.y -= gravity * delta; // Apply gravity
                        canJump = false;
                    }

                    // Apply movement
                    controls.getObject().position.x += playerVelocity.x * delta;
                    controls.getObject().position.z += playerVelocity.z * delta;
                    controls.getObject().position.y += playerVelocity.y * delta;

                    // Basic floor clamp (redundant if ground check works well, but acts as safety)
                    if (controls.getObject().position.y < playerHeight - playerFeetOffset + 0.1) { // Keep feet slightly above 0
                        const feetRay = new THREE.Raycaster(controls.getObject().position, new THREE.Vector3(0, -1, 0), 0, playerHeight);
                        const floorHit = feetRay.intersectObjects(objects.filter(o => o.userData.type === 'ground' || o.userData.structure), false);
                        if(floorHit.length > 0){
                             const floorY = floorHit[0].point.y;
                             if(controls.getObject().position.y < floorY + (playerHeight - playerFeetOffset)){
                                controls.getObject().position.y = floorY + (playerHeight - playerFeetOffset);
                                playerVelocity.y = 0;
                                canJump = true;
                             }
                        } else { // Failsafe if somehow below 0 without intersecting ground object
                             if (controls.getObject().position.y < (playerHeight - playerFeetOffset)){
                                controls.getObject().position.y = playerHeight - playerFeetOffset;
                                playerVelocity.y = 0;
                                canJump = true;
                             }
                        }
                    }

                    checkInteraction();
                    // updateHUD(); // Update HUD every frame or less frequently?
                } else {
                    playerVelocity.set(0, 0, 0);
                }

                renderer.render(scene, camera);
            }
        } // End of else block (if THREE is defined)
    </script>
</body>
</html>
