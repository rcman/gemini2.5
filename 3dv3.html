<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic 3D Survival (Configurable)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #333; color: white; }
        canvas { display: block; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7); /* Slightly darker overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100; /* Ensure it's on top initially */
        }
        #instructions { /* Renamed conceptually to config screen */
            width: 80%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 14px;
            background-color: rgba(50, 50, 50, 0.9);
            border-radius: 10px;
            padding: 30px 20px;
            border: 1px solid grey;
        }
        #instructions h1 {
            margin-top: 0;
            margin-bottom: 20px;
        }
        .config-item {
            margin-bottom: 15px;
            width: 100%;
            display: flex;
            justify-content: space-between; /* Align label and input */
            align-items: center;
            padding: 0 10px; /* Add some padding */
            box-sizing: border-box;
        }
        .config-item label {
            margin-right: 10px;
            flex-basis: 40%; /* Give label some space */
            text-align: right;
        }
        .config-item input[type="number"] {
            padding: 5px;
            width: 80px; /* Fixed width for number inputs */
            border: 1px solid grey;
            border-radius: 3px;
            background-color: #ddd;
            color: #333;
            text-align: center;
            flex-basis: 50%; /* Give input space */
        }
        #start-button {
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 20px;
            transition: background-color 0.2s;
        }
        #start-button:hover {
            background-color: #45a049;
        }
        /* --- Rest of the styles from previous version --- */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background-color: white; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        .hud { position: absolute; top: 10px; left: 10px; background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; font-size: 14px; }
        #quick-bar { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; }
        .quick-slot { width: 50px; height: 50px; border: 2px solid grey; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; font-size: 10px; position: relative; color: white; overflow: hidden; }
        .quick-slot.active { border-color: white; }
        .slot-item { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 10px; overflow: hidden; color: black; background-color: lightgrey; line-height: 1.2; padding: 2px; box-sizing: border-box; }
        .slot-quantity { position: absolute; bottom: 2px; right: 2px; font-size: 10px; background-color: rgba(0,0,0,0.7); color: white; padding: 1px 3px; border-radius: 2px; }
        #inventory, #build-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; max-width: 90vw; background-color: rgba(50, 50, 50, 0.9); border: 2px solid grey; border-radius: 10px; padding: 20px; display: none; flex-direction: column; align-items: center; z-index: 10; }
        #inventory h2, #build-menu h2 { margin-top: 0; }
        #inventory-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 5px; width: 100%; max-height: 250px; overflow-y: auto; margin-bottom: 10px; }
        .inventory-slot { width: 50px; height: 50px; border: 1px solid dimgrey; background-color: rgba(0,0,0,0.4); position: relative; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        #build-options { display: flex; flex-direction: column; gap: 10px; width: 100%; align-items: center; max-height: 250px; overflow-y: auto; margin-bottom: 10px; }
        #build-options button { padding: 8px 15px; background-color: #444; border: 1px solid grey; color: white; cursor: pointer; width: 90%; font-size: 12px; }
        #build-options button:hover { background-color: #555; }
        #interaction-prompt { position: absolute; top: 60%; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 3px; font-size: 12px; display: none; z-index: 5; }
        #message-area { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(255, 0, 0, 0.7); color: white; padding: 10px 15px; border-radius: 5px; display: none; text-align: center; z-index: 20; font-size: 14px; }

    </style>
</head>
<body>
    <!-- Blocker Screen for Configuration -->
    <div id="blocker">
        <div id="instructions"> <!-- Reusing the div, styling updated -->
            <h1>World Configuration</h1>
            <div class="config-item">
                <label for="num-trees-input">Number of Trees:</label>
                <input type="number" id="num-trees-input" value="100" min="0" max="500">
            </div>
            <div class="config-item">
                <label for="num-rocks-input">Number of Rocks:</label>
                <input type="number" id="num-rocks-input" value="80" min="0" max="500">
            </div>
            <div class="config-item">
                <label for="num-barrels-input">Number of Barrels:</label>
                <input type="number" id="num-barrels-input" value="15" min="0" max="100">
            </div>
            <p style="font-size: 12px; margin-top: 15px; color: #ccc;">
                Move: WASD | Jump: SPACE | Look: MOUSE <br>
                Interact/Use: E or Left Mouse | Inv: I | Build: B | Quick Slots: 1-5
            </p>
            <button id="start-button">Start Game</button>
        </div>
    </div>

    <!-- Game Elements (initially hidden conceptually by blocker) -->
    <div id="crosshair" style="display: none;">+</div>
    <div class="hud" style="display: none;">
        <div>Health: <span id="health">100</span></div>
        <div>Hunger: <span id="hunger">100</span></div>
        <div>Thirst: <span id="thirst">100</span></div>
    </div>
    <div id="quick-bar" style="display: none;">
        <div class="quick-slot" data-slot="0"></div>
        <div class="quick-slot" data-slot="1"></div>
        <div class="quick-slot" data-slot="2"></div>
        <div class="quick-slot" data-slot="3"></div>
        <div class="quick-slot" data-slot="4"></div>
    </div>
    <div id="inventory"><h2>Inventory</h2><div id="inventory-grid"></div><p style="font-size: 12px; margin-top: 10px;">Press 'I' or 'ESC' to close</p></div>
    <div id="build-menu"><h2>Build Menu</h2><div id="build-options"><!-- Buttons --></div><p style="font-size: 12px; margin-top: 10px;">Press 'B' or 'ESC' to close</p></div>
    <div id="interaction-prompt"></div>
    <div id="message-area"></div>

    <!-- Libraries -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // PointerLockControls definition (same as before)
        var PointerLockControls = function ( camera, domElement ) { /* ... */ };
        PointerLockControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        PointerLockControls.prototype.constructor = PointerLockControls;
        // (Paste the full PointerLockControls code here from the previous version)
        var PointerLockControls = function ( camera, domElement ) {
            if ( domElement === undefined ) {
                console.warn( 'THREE.PointerLockControls: The second parameter "domElement" is now mandatory.' );
                domElement = document.body;
            }
            this.domElement = domElement;
            this.isLocked = false;
            this.minPolarAngle = 0; this.maxPolarAngle = Math.PI;
            var scope = this;
            var changeEvent = { type: 'change' }; var lockEvent = { type: 'lock' }; var unlockEvent = { type: 'unlock' };
            var euler = new THREE.Euler( 0, 0, 0, 'YXZ' ); var PI_2 = Math.PI / 2; var vec = new THREE.Vector3();
            function onMouseMove( event ) {
                if ( scope.isLocked === false ) return;
                var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                euler.setFromQuaternion( camera.quaternion );
                euler.y -= movementX * 0.002; euler.x -= movementY * 0.002;
                euler.x = Math.max( PI_2 - scope.maxPolarAngle, Math.min( PI_2 - scope.minPolarAngle, euler.x ) );
                camera.quaternion.setFromEuler( euler ); scope.dispatchEvent( changeEvent );
            }
            function onPointerlockChange() {
                const blocker = document.getElementById('blocker'); // Need access to blocker here
                const instructions = document.getElementById('instructions'); // And instructions
                if ( document.pointerLockElement === scope.domElement ) {
                    scope.dispatchEvent( lockEvent );
                    scope.isLocked = true;
                    // When locked during gameplay, blocker should be hidden
                    blocker.style.display = 'none';
                } else {
                    scope.dispatchEvent( unlockEvent );
                    scope.isLocked = false;
                    // When unlocked (paused), show blocker ONLY IF a menu is NOT open
                    if (!isInventoryOpen && !isBuildMenuOpen) {
                        blocker.style.display = 'flex';
                        instructions.innerHTML = '<h1>Paused</h1><p>(Click to resume)</p>'; // Show pause message
                        instructions.style.display = 'flex'; // Ensure pause message is visible
                    } else {
                        // If a menu is open, the blocker is already handled by the menu toggle,
                        // so we don't need to force it visible here. Keep pause message hidden.
                         instructions.style.display = 'none';
                    }
                }
            }
            function onPointerlockError() { console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' ); }
            this.connect = function () {
                document.addEventListener( 'mousemove', onMouseMove, false );
                document.addEventListener( 'pointerlockchange', onPointerlockChange, false );
                document.addEventListener( 'pointerlockerror', onPointerlockError, false );
            };
            this.disconnect = function () {
                document.removeEventListener( 'mousemove', onMouseMove, false );
                document.removeEventListener( 'pointerlockchange', onPointerlockChange, false );
                document.removeEventListener( 'pointerlockerror', onPointerlockError, false );
            };
            this.dispose = function () { this.disconnect(); };
            this.getObject = function () { return camera; };
            this.getDirection = function () { var direction = new THREE.Vector3( 0, 0, - 1 ); return function ( v ) { return v.copy( direction ).applyQuaternion( camera.quaternion ); }; }();
            this.moveForward = function ( distance ) { vec.setFromMatrixColumn( camera.matrix, 0 ); vec.crossVectors( camera.up, vec ); camera.position.addScaledVector( vec, distance ); };
            this.moveRight = function ( distance ) { vec.setFromMatrixColumn( camera.matrix, 0 ); camera.position.addScaledVector( vec, distance ); };
            this.lock = function () { this.domElement.requestPointerLock(); };
            this.unlock = function () { document.exitPointerLock(); };
            // Don't auto-connect here, connect after init
            // this.connect(); // REMOVE THIS
        };
        PointerLockControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        PointerLockControls.prototype.constructor = PointerLockControls;
    </script>

    <script>
        // --- Ensure Three.js is loaded ---
        if (typeof THREE === 'undefined') {
            const blocker = document.getElementById('blocker');
            blocker.innerHTML = '<div id="instructions" style="color:red;"><h1>Error</h1><p>Three.js library failed to load.<br>This might be due to using an HTTP link which is often blocked or redirected.<br>Check the browser console (F12) for details.</p></div>';
            blocker.style.display = 'flex'; // Make sure error is visible
        } else {
            // --- Game Setup Variables ---
            let scene, camera, renderer, controls;
            let clock; // Initialized later
            let raycaster; // Initialized later
            const objects = [];
            let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
            let canJump = false;
            let playerVelocity = new THREE.Vector3();
            const playerHeight = 1.8, playerFeetOffset = 0.9;
            const moveSpeed = 5.0, jumpVelocity = 7.0, gravity = 15.0;

            // --- World Generation Config (Defaults, will be updated) ---
            let NUM_TREES = 100;
            let NUM_ROCKS = 80;
            let NUM_BARRELS = 15;
            const WORLD_SPAWN_RADIUS = 150;

            // --- UI State Variables ---
            let isInventoryOpen = false;
            let isBuildMenuOpen = false;
            let currentInteractable = null;

            // --- Player State ---
            const player = { /* ... (same as before) ... */
                health: 100, hunger: 100, thirst: 100, inventory: [], quickBar: new Array(5).fill(null), inventorySize: 20, currentQuickSlot: 0,
                startItems: [
                    { id: 'axe_basic', name: 'Basic Axe', quantity: 1, type: 'tool', harvest: ['tree'] },
                    { id: 'pickaxe_basic', name: 'Basic Pickaxe', quantity: 1, type: 'tool', harvest: ['rock'] },
                    { id: 'knife_basic', name: 'Basic Knife', quantity: 1, type: 'tool', harvest: ['animal'] },
                    { id: 'canteen_empty', name: 'Canteen', quantity: 1, type: 'container', contains: null, capacity: 1 }
                ]
             };

            // --- UI Elements ---
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions'); // Now the config screen
            const startButton = document.getElementById('start-button');
            // Get other UI elements (declare them here so functions can access them)
            const healthElement = document.getElementById('health');
            const hungerElement = document.getElementById('hunger');
            const thirstElement = document.getElementById('thirst');
            const quickBarSlots = document.querySelectorAll('.quick-slot');
            const inventoryPanel = document.getElementById('inventory');
            const inventoryGrid = document.getElementById('inventory-grid');
            const buildMenuPanel = document.getElementById('build-menu');
            const buildOptions = document.getElementById('build-options');
            const interactionPrompt = document.getElementById('interaction-prompt');
            const messageArea = document.getElementById('message-area');
            const crosshair = document.getElementById('crosshair');
            const hud = document.querySelector('.hud');
            const quickBar = document.getElementById('quick-bar');
            let messageTimeout = null;

            // --- Game Data ---
            const itemData = { /* ... (same as before) ... */
                'wood': { name: 'Wood', stackSize: 50, type: 'resource' }, 'stone': { name: 'Stone', stackSize: 50, type: 'resource' }, 'scrap_metal': { name: 'Scrap Metal', stackSize: 30, type: 'resource' }, 'nails': { name: 'Nails', stackSize: 100, type: 'resource' }, 'raw_meat': { name: 'Raw Meat', stackSize: 10, type: 'food' }, 'cooked_meat': { name: 'Cooked Meat', stackSize: 10, type: 'food' }, 'leather': { name: 'Leather', stackSize: 20, type: 'resource' }, 'animal_fat': { name: 'Animal Fat', stackSize: 15, type: 'resource' }, 'dirty_water': { name: 'Dirty Water', stackSize: 1, type: 'water' }, 'clean_water': { name: 'Clean Water', stackSize: 1, type: 'water' },
                'axe_basic': { name: 'Basic Axe', stackSize: 1, type: 'tool', harvest: ['tree'] }, 'pickaxe_basic': { name: 'Basic Pickaxe', stackSize: 1, type: 'tool', harvest: ['rock'] }, 'knife_basic': { name: 'Basic Knife', stackSize: 1, type: 'tool', harvest: ['animal'] }, 'canteen_empty': { name: 'Canteen', stackSize: 1, type: 'container', contains: null, capacity: 1 }, 'canteen_dirty': { name: 'Canteen (Dirty)', stackSize: 1, type: 'container', contains: 'dirty_water', capacity: 1 }, 'canteen_clean': { name: 'Canteen (Clean)', stackSize: 1, type: 'container', contains: 'clean_water', capacity: 1 },
                'campfire': { name: 'Campfire', stackSize: 1, type: 'placeable', interact: 'cook_ui' }, 'foundation': { name: 'Foundation', stackSize: 1, type: 'placeable', structure: true }, 'wall': { name: 'Wall', stackSize: 1, type: 'placeable', structure: true }, 'wall_window': { name: 'Wall w/ Window', stackSize: 1, type: 'placeable', structure: true }, 'wall_doorway': { name: 'Wall w/ Doorway', stackSize: 1, type: 'placeable', structure: true }, 'door': { name: 'Door', stackSize: 1, type: 'placeable', structure: true, interact: 'toggle_open' }, 'roof': { name: 'Roof', stackSize: 1, type: 'placeable', structure: true },
            };
            const recipes = { /* ... (same as before) ... */
                 'axe_basic': { 'wood': 3, 'stone': 2 }, 'pickaxe_basic': { 'wood': 3, 'stone': 3 }, 'campfire': { 'wood': 5, 'stone': 5 }, 'foundation': { 'wood': 20 }, 'wall': { 'wood': 15 }, 'wall_window': { 'wood': 12 }, 'wall_doorway': { 'wood': 10 }, 'door': { 'wood': 8 }, 'roof': { 'wood': 15 },
            };

            // --- Core Functions (init, animate, etc.) ---
            // Define functions before they are called by the event listener

            function init() {
                // Initialize things that need to exist for the game loop
                clock = new THREE.Clock();
                raycaster = new THREE.Raycaster();

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.y = playerHeight;

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement); // Add canvas to body

                // Lighting (same as before)
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(15, 30, 10); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 100; directionalLight.shadow.camera.left = -50; directionalLight.shadow.camera.right = 50; directionalLight.shadow.camera.top = 50; directionalLight.shadow.camera.bottom = -50; scene.add(directionalLight);

                // Controls - Initialize and CONNECT here
                controls = new PointerLockControls(camera, document.body);
                controls.connect(); // Connect event listeners now
                scene.add(controls.getObject());

                // Add listeners needed DURING gameplay
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.addEventListener('mousedown', onMouseDown);
                window.addEventListener('resize', onWindowResize);

                // --- World Generation (Uses the updated NUM_ constants) ---
                createGround();
                createWater();
                console.log(`Generating ${NUM_TREES} trees, ${NUM_ROCKS} rocks, ${NUM_BARRELS} barrels.`);
                for (let i = 0; i < NUM_TREES; i++) createTree(Math.random() * WORLD_SPAWN_RADIUS * 2 - WORLD_SPAWN_RADIUS, Math.random() * WORLD_SPAWN_RADIUS * 2 - WORLD_SPAWN_RADIUS);
                for (let i = 0; i < NUM_ROCKS; i++) createRock(Math.random() * WORLD_SPAWN_RADIUS * 2 - WORLD_SPAWN_RADIUS, Math.random() * WORLD_SPAWN_RADIUS * 2 - WORLD_SPAWN_RADIUS);
                const barrelRadius = WORLD_SPAWN_RADIUS * 0.8; // Spawn barrels slightly closer
                for (let i = 0; i < NUM_BARRELS; i++) createBarrel(Math.random() * barrelRadius * 2 - barrelRadius, Math.random() * barrelRadius * 2 - barrelRadius);

                // --- Player Setup ---
                giveStartItems();
                updateQuickBarUI();
                updateInventoryUI(); // Safe to call now
                updateHUD();
                setActiveQuickSlot(0);
                setupBuildMenuActions();

                // Make sure game UI is visible now that init is done
                crosshair.style.display = 'block';
                hud.style.display = 'block';
                quickBar.style.display = 'flex'; // Use flex as it's a flex container
            }

            // --- World Object Creation Functions --- (createGround, createTree, etc. - same as before)
            function createGround() { /* ... */
                 const groundGeometry = new THREE.PlaneGeometry(500, 500); const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x3c602a, roughness: 0.9, metalness: 0.1 }); const ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; ground.userData = { type: 'ground' }; scene.add(ground); objects.push(ground);
            }
            function createWater() { /* ... */
                 const waterGeometry = new THREE.PlaneGeometry(100, 100); const waterMaterial = new THREE.MeshStandardMaterial({ color: 0x4682B4, transparent: true, opacity: 0.8, roughness: 0.2, metalness: 0.3 }); const water = new THREE.Mesh(waterGeometry, waterMaterial); water.rotation.x = -Math.PI / 2; water.position.set(150, -0.05, 0); water.userData = { type: 'water_source' }; scene.add(water); objects.push(water);
            }
            function createTree(x, z) { /* ... */
                const trunkHeight = Math.random() * 4 + 3; const trunkRadius = Math.random() * 0.3 + 0.2; const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8); const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6a4a3a, roughness: 0.8 }); const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.castShadow = true; trunk.receiveShadow = true; const leavesHeight = trunkHeight * 1.0; const leavesRadius = trunkRadius * (Math.random() * 2 + 4); const leavesGeo = new THREE.IcosahedronGeometry(leavesRadius, 0); const leavesMat = new THREE.MeshStandardMaterial({ color: 0x2a4f2a, roughness: 0.9 }); const leaves = new THREE.Mesh(leavesGeo, leavesMat); leaves.position.y = trunkHeight * 0.7; leaves.castShadow = true; leaves.receiveShadow = true; const tree = new THREE.Group(); tree.add(trunk); tree.add(leaves); tree.position.set(x, trunkHeight / 2, z); scene.add(tree); trunk.userData = { type: 'tree', health: 100, resource: 'wood', drops: { wood: 5 + Math.floor(Math.random() * 6) }, group: tree, mainMesh: trunk }; objects.push(trunk);
             }
            function createRock(x, z) { /* ... */
                 const rockSize = Math.random() * 1 + 0.5; const rockGeo = new THREE.IcosahedronGeometry(rockSize, 0); const rockMat = new THREE.MeshStandardMaterial({ color: 0x777777, roughness: 0.7 }); const rock = new THREE.Mesh(rockGeo, rockMat); rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI); rock.position.set(x, rockSize * 0.5, z); rock.castShadow = true; rock.receiveShadow = true; rock.userData = { type: 'rock', health: 150, resource: 'stone', drops: { stone: 3 + Math.floor(Math.random() * 4) }, mainMesh: rock }; scene.add(rock); objects.push(rock);
            }
            function createBarrel(x, z) { /* ... */
                const barrelHeight = 1; const barrelRadius = 0.4; const barrelGeo = new THREE.CylinderGeometry(barrelRadius, barrelRadius, barrelHeight, 12); const barrelMat = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.6, metalness: 0.2 }); const barrel = new THREE.Mesh(barrelGeo, barrelMat); barrel.position.set(x, barrelHeight / 2, z); barrel.castShadow = true; barrel.receiveShadow = true; const possibleLoot = [ { id: 'scrap_metal', quantity: [2, 6] }, { id: 'nails', quantity: [5, 20] }, { id: 'raw_meat', quantity: [1, 1] }, { id: 'canteen_empty', quantity: [1, 1] }, { id: 'animal_fat', quantity: [1, 3] }, ]; barrel.userData = { type: 'barrel', looted: false, lootTable: possibleLoot, mainMesh: barrel }; scene.add(barrel); objects.push(barrel);
            }

            // --- Player/Inventory/UI/Interaction Functions --- (giveStartItems, addItemToInventory, updateHUD, etc. - same as before)
            function giveStartItems() { /* ... */ player.startItems.forEach(itemInfo => { addItemToInventory(itemInfo.id, itemInfo.quantity); }); }
            function getSelectedItem() { /* ... */ return player.quickBar[player.currentQuickSlot]; }
            function setActiveQuickSlot(slotIndex) { /* ... */ slotIndex = Math.max(0, Math.min(quickBarSlots.length - 1, slotIndex)); quickBarSlots[player.currentQuickSlot].classList.remove('active'); player.currentQuickSlot = slotIndex; quickBarSlots[player.currentQuickSlot].classList.add('active'); }
            function displayMessage(text, duration = 3000, isError = false) { /* ... */ if (messageTimeout) clearTimeout(messageTimeout); messageArea.textContent = text; messageArea.style.backgroundColor = isError ? 'rgba(200, 0, 0, 0.8)' : 'rgba(0, 100, 0, 0.8)'; messageArea.style.display = 'block'; messageTimeout = setTimeout(() => { messageArea.style.display = 'none'; messageTimeout = null; }, duration); }
            function findFirstFreeQuickSlot() { /* ... */ return player.quickBar.findIndex(slot => slot === null); }
            function findFirstFreeInventorySlotIndex() { /* ... */ return player.inventory.length < player.inventorySize ? player.inventory.length : -1; }
            function findItemStack(itemId, checkQuickBar = true, checkInventory = true) { /* ... */ const baseItemInfo = itemData[itemId]; if (!baseItemInfo) return null; const stackSize = baseItemInfo.stackSize || 1; if (checkQuickBar) { for (let i = 0; i < player.quickBar.length; i++) { const item = player.quickBar[i]; if (item && item.id === itemId && item.quantity < stackSize) { return { location: 'quickbar', index: i, item: item }; } } } if (checkInventory) { for (let i = 0; i < player.inventory.length; i++) { const item = player.inventory[i]; if (item && item.id === itemId && item.quantity < stackSize) { return { location: 'inventory', index: i, item: item }; } } } return null; }
            function addItemToInventory(itemId, quantity) { /* ... */ const baseItemInfo = itemData[itemId]; if (!baseItemInfo) { console.error("Attempted to add unknown item:", itemId); return false; } const stackSize = baseItemInfo.stackSize || 1; let remainingQuantity = quantity; while (remainingQuantity > 0) { const existingStack = findItemStack(itemId, true, true); if (existingStack) { const canAdd = stackSize - existingStack.item.quantity; const amountToAdd = Math.min(remainingQuantity, canAdd); existingStack.item.quantity += amountToAdd; remainingQuantity -= amountToAdd; } else { break; } } while (remainingQuantity > 0) { const freeQuickSlot = findFirstFreeQuickSlot(); if (freeQuickSlot !== -1) { const amountToAdd = Math.min(remainingQuantity, stackSize); const newItem = { ...baseItemInfo, id: itemId, quantity: amountToAdd }; if(newItem.type === 'container') { newItem.contains = baseItemInfo.contains !== undefined ? baseItemInfo.contains : null; newItem.capacity = baseItemInfo.capacity || 1; } player.quickBar[freeQuickSlot] = newItem; remainingQuantity -= amountToAdd; } else { break; } } while (remainingQuantity > 0) { const freeInvSlotIndex = findFirstFreeInventorySlotIndex(); if (freeInvSlotIndex !== -1) { const amountToAdd = Math.min(remainingQuantity, stackSize); const newItem = { ...baseItemInfo, id: itemId, quantity: amountToAdd }; if(newItem.type === 'container') { newItem.contains = baseItemInfo.contains !== undefined ? baseItemInfo.contains : null; newItem.capacity = baseItemInfo.capacity || 1; } player.inventory.push(newItem); remainingQuantity -= amountToAdd; } else { if (remainingQuantity > 0) { displayMessage(`Inventory full! ${remainingQuantity} ${baseItemInfo.name} lost.`, 4000, true); console.warn("Inventory full, couldn't add remaining:", remainingQuantity, itemId); } break; } } updateQuickBarUI(); updateInventoryUI(); return remainingQuantity <= 0; }
            function getTotalResourceCount(itemId) { /* ... */ let count = 0; player.quickBar.forEach(item => { if (item && item.id === itemId) count += item.quantity; }); player.inventory.forEach(item => { if (item && item.id === itemId) count += item.quantity; }); return count; }
            function consumeResources(resourcesNeeded) { /* ... */ for (const itemId in resourcesNeeded) { const required = resourcesNeeded[itemId]; const available = getTotalResourceCount(itemId); if (available < required) { displayMessage(`Not enough ${itemData[itemId]?.name || itemId}! Need ${required}, have ${available}.`, 3000, true); return false; } } for (const itemId in resourcesNeeded) { let remainingToConsume = resourcesNeeded[itemId]; for (let i = 0; i < player.quickBar.length && remainingToConsume > 0; i++) { const item = player.quickBar[i]; if (item && item.id === itemId) { const amountToTake = Math.min(remainingToConsume, item.quantity); item.quantity -= amountToTake; remainingToConsume -= amountToTake; if (item.quantity <= 0) player.quickBar[i] = null; } } for (let i = player.inventory.length - 1; i >= 0 && remainingToConsume > 0; i--) { const item = player.inventory[i]; if (item && item.id === itemId) { const amountToTake = Math.min(remainingToConsume, item.quantity); item.quantity -= amountToTake; remainingToConsume -= amountToTake; if (item.quantity <= 0) player.inventory.splice(i, 1); } } } updateQuickBarUI(); updateInventoryUI(); return true; }
            function updateHUD() { /* ... */ healthElement.textContent = player.health; hungerElement.textContent = player.hunger; thirstElement.textContent = player.thirst; }
            function updateQuickBarUI() { /* ... */ quickBarSlots.forEach((slotElement, index) => { const item = player.quickBar[index]; slotElement.innerHTML = ''; if (item) { const itemDiv = document.createElement('div'); itemDiv.classList.add('slot-item'); itemDiv.textContent = item.name; itemDiv.title = `${item.name} (${item.quantity})`; if(item.type === 'tool') itemDiv.style.backgroundColor = 'lightblue'; else if(item.type === 'resource') itemDiv.style.backgroundColor = 'sandybrown'; else if(item.type === 'food') itemDiv.style.backgroundColor = 'lightcoral'; else if(item.type === 'container') itemDiv.style.backgroundColor = 'lightgrey'; else if(item.type === 'placeable') itemDiv.style.backgroundColor = 'lightgreen'; slotElement.appendChild(itemDiv); if ((itemData[item.id]?.stackSize || 1) > 1 && item.quantity > 1) { const quantityDiv = document.createElement('div'); quantityDiv.classList.add('slot-quantity'); quantityDiv.textContent = item.quantity; slotElement.appendChild(quantityDiv); } } }); }
            function toggleInventory() { /* ... */ isInventoryOpen = !isInventoryOpen; inventoryPanel.style.display = isInventoryOpen ? 'flex' : 'none'; blocker.style.display = isInventoryOpen || isBuildMenuOpen ? 'flex' : 'none'; if (isInventoryOpen) { controls.unlock(); instructions.style.display = 'none'; updateInventoryUI(); if(isBuildMenuOpen) toggleBuildMenu(); } else { if (!isBuildMenuOpen) { setTimeout(() => { if (!isInventoryOpen && !isBuildMenuOpen) controls.lock(); }, 50); } } }
            function updateInventoryUI() { /* ... */ if (!isInventoryOpen && !inventoryGrid) return; inventoryGrid.innerHTML = ''; player.inventory.forEach((item, index) => { const slotElement = document.createElement('div'); slotElement.classList.add('inventory-slot'); slotElement.title = `${item.name} (${item.quantity})`; const itemDiv = document.createElement('div'); itemDiv.classList.add('slot-item'); itemDiv.textContent = item.name; if(item.type === 'tool') itemDiv.style.backgroundColor = 'lightblue'; else if(item.type === 'resource') itemDiv.style.backgroundColor = 'sandybrown'; else if(item.type === 'food') itemDiv.style.backgroundColor = 'lightcoral'; else if(item.type === 'container') itemDiv.style.backgroundColor = 'lightgrey'; else if(item.type === 'placeable') itemDiv.style.backgroundColor = 'lightgreen'; slotElement.appendChild(itemDiv); if ((itemData[item.id]?.stackSize || 1) > 1 && item.quantity > 1) { const quantityDiv = document.createElement('div'); quantityDiv.classList.add('slot-quantity'); quantityDiv.textContent = item.quantity; slotElement.appendChild(quantityDiv); } inventoryGrid.appendChild(slotElement); }); const emptySlotsCount = player.inventorySize - player.inventory.length; for (let i = 0; i < emptySlotsCount; i++) { const slotElement = document.createElement('div'); slotElement.classList.add('inventory-slot'); inventoryGrid.appendChild(slotElement); } }
            function toggleBuildMenu() { /* ... */ isBuildMenuOpen = !isBuildMenuOpen; buildMenuPanel.style.display = isBuildMenuOpen ? 'flex' : 'none'; blocker.style.display = isInventoryOpen || isBuildMenuOpen ? 'flex' : 'none'; if (isBuildMenuOpen) { controls.unlock(); instructions.style.display = 'none'; if(isInventoryOpen) toggleInventory(); } else { if (!isInventoryOpen) { setTimeout(() => { if (!isInventoryOpen && !isBuildMenuOpen) controls.lock(); }, 50); } } }
            function setupBuildMenuActions() { /* ... */ buildOptions.querySelectorAll('button').forEach(button => { button.addEventListener('click', () => { const itemId = button.dataset.item; if (recipes[itemId]) { attemptCraft(itemId); } else { displayMessage(`Recipe for ${itemData[itemId]?.name || itemId} not found.`, 3000, true); console.warn("Recipe missing for button:", itemId); } }); }); }
            function attemptCraft(itemId) { /* ... */ const recipe = recipes[itemId]; if (!recipe) return; if (consumeResources(recipe)) { if (addItemToInventory(itemId, 1)) { displayMessage(`Crafted ${itemData[itemId]?.name || itemId}!`, 2000); } else { displayMessage(`Crafted ${itemData[itemId]?.name || itemId}, but inventory was full! Item lost.`, 4000, true); console.error("Inventory full after crafting, resources consumed but item lost:", itemId); } } }
            function checkInteraction() { /* ... */ if (!controls.isLocked) { hideInteractionPrompt(); currentInteractable = null; return; } raycaster.setFromCamera({ x: 0, y: 0 }, camera); const potentialTargets = objects.filter(o => o.userData.type && o.userData.type !== 'ground'); const intersects = raycaster.intersectObjects(potentialTargets, false); let foundInteractable = false; if (intersects.length > 0) { const intersection = intersects[0]; const object = intersection.object.userData.mainMesh || intersection.object; const distance = intersection.distance; if (distance < 3.5 && object.userData.type) { if (currentInteractable !== object) { currentInteractable = object; showInteractionPrompt(object); } foundInteractable = true; } } if (!foundInteractable && currentInteractable) { hideInteractionPrompt(); currentInteractable = null; } }
            function showInteractionPrompt(object) { /* ... */ let text = ''; const data = object.userData; const selectedItem = getSelectedItem(); switch(data.type) { case 'tree': text = `[E] Harvest Tree ${selectedItem?.id.includes('axe') ? `(HP: ${data.health})` : '(Need Axe)'}`; break; case 'rock': text = `[E] Harvest Rock ${selectedItem?.id.includes('pickaxe') ? `(HP: ${data.health})` : '(Need Pickaxe)'}`; break; case 'barrel': text = data.looted ? 'Barrel (Empty)' : '[E] Loot Barrel'; break; case 'water_source': const hasEmptyCanteen = [...player.quickBar, ...player.inventory].some(item => item?.id === 'canteen_empty'); text = hasEmptyCanteen ? `[E] Collect Water` : 'Need Empty Canteen'; break; default: text = '[E] Interact'; } interactionPrompt.textContent = text; interactionPrompt.style.display = 'block'; }
            function hideInteractionPrompt() { /* ... */ interactionPrompt.style.display = 'none'; }
            function performInteraction() { /* ... (logic same as before) ... */ if (!currentInteractable || !controls.isLocked) return; const data = currentInteractable.userData; const selectedItem = getSelectedItem(); const interactionObject = currentInteractable; switch(data.type) { case 'tree': if (selectedItem && itemData[selectedItem.id]?.harvest?.includes('tree')) { data.health -= 25; showInteractionPrompt(interactionObject); if (data.health <= 0) { displayMessage(`Harvested Tree!`, 2000); for (const resourceId in data.drops) addItemToInventory(resourceId, data.drops[resourceId]); scene.remove(data.group); const index = objects.findIndex(o => o === interactionObject); if (index > -1) objects.splice(index, 1); currentInteractable = null; hideInteractionPrompt(); } } else { displayMessage("Need an axe to harvest trees.", 2000, true); } break; case 'rock': if (selectedItem && itemData[selectedItem.id]?.harvest?.includes('rock')) { data.health -= 20; showInteractionPrompt(interactionObject); if (data.health <= 0) { displayMessage(`Harvested Rock!`, 2000); for (const resourceId in data.drops) addItemToInventory(resourceId, data.drops[resourceId]); scene.remove(interactionObject); const index = objects.findIndex(o => o === interactionObject); if (index > -1) objects.splice(index, 1); currentInteractable = null; hideInteractionPrompt(); } } else { displayMessage("Need a pickaxe to harvest rocks.", 2000, true); } break; case 'barrel': if (!data.looted) { data.looted = true; let lootGained = false; const lootTable = data.lootTable || []; const numItemsToDrop = Math.floor(Math.random() * 2) + 1; for(let i=0; i < numItemsToDrop; i++){ if(lootTable.length > 0){ const lootEntryIndex = Math.floor(Math.random() * lootTable.length); const chosenLootInfo = lootTable[lootEntryIndex]; const quantity = Math.floor(Math.random() * (chosenLootInfo.quantity[1] - chosenLootInfo.quantity[0] + 1)) + chosenLootInfo.quantity[0]; if (addItemToInventory(chosenLootInfo.id, quantity)) { displayMessage(`Found ${quantity} ${itemData[chosenLootInfo.id]?.name || chosenLootInfo.id}!`, 2500); lootGained = true; } } } if (!lootGained) displayMessage("Barrel seems empty...", 1500); showInteractionPrompt(interactionObject); } else { displayMessage("Barrel is empty.", 1500); } break; case 'water_source': let canteenSlot = null; let canteenIndex = -1; let canteenLocation = null; for(let i=0; i < player.quickBar.length; i++){ if(player.quickBar[i]?.id === 'canteen_empty'){ canteenSlot = player.quickBar[i]; canteenIndex = i; canteenLocation = 'quickbar'; break; } } if(!canteenSlot){ for(let i=0; i < player.inventory.length; i++){ if(player.inventory[i]?.id === 'canteen_empty'){ canteenSlot = player.inventory[i]; canteenIndex = i; canteenLocation = 'inventory'; break; } } } if(canteenSlot){ const dirtyCanteenData = itemData['canteen_dirty']; const newCanteen = { ...dirtyCanteenData, id: 'canteen_dirty', quantity: 1 }; if(canteenLocation === 'quickbar') { player.quickBar[canteenIndex] = newCanteen; updateQuickBarUI(); } else if (canteenLocation === 'inventory') { player.inventory[canteenIndex] = newCanteen; updateInventoryUI(); } displayMessage('Filled canteen with dirty water. Boil it!', 3000); } else { displayMessage("Need an empty canteen to collect water.", 2000, true); } showInteractionPrompt(interactionObject); break; } }

            // --- Event Handlers ---
            function onWindowResize() { /* ... */ if(!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
            function onKeyDown(event) { /* ... */ if (event.key.toLowerCase() === 'i') { toggleInventory(); return; } if (event.key.toLowerCase() === 'b') { toggleBuildMenu(); return; } if (event.key === 'Escape') { if (isInventoryOpen) toggleInventory(); else if (isBuildMenuOpen) toggleBuildMenu(); return; } if (!controls || !controls.isLocked) return; switch (event.key.toLowerCase()) { case 'w': moveForward = true; break; case 'a': moveLeft = true; break; case 's': moveBackward = true; break; case 'd': moveRight = true; break; case ' ': if (canJump) playerVelocity.y += jumpVelocity; canJump = false; break; case 'e': performInteraction(); break; case '1': setActiveQuickSlot(0); break; case '2': setActiveQuickSlot(1); break; case '3': setActiveQuickSlot(2); break; case '4': setActiveQuickSlot(3); break; case '5': setActiveQuickSlot(4); break; } }
            function onKeyUp(event) { /* ... */ switch (event.key.toLowerCase()) { case 'w': moveForward = false; break; case 'a': moveLeft = false; break; case 's': moveBackward = false; break; case 'd': moveRight = false; break; } }
            function onMouseDown(event) { /* ... */ if (!controls || !controls.isLocked) return; if (event.button === 0) { performInteraction(); } }

            // --- Game Loop ---
            function animate() { /* ... (same as before) ... */ requestAnimationFrame(animate); const delta = Math.min(0.05, clock.getDelta()); if (controls.isLocked) { playerVelocity.x -= playerVelocity.x * 10.0 * delta; playerVelocity.z -= playerVelocity.z * 10.0 * delta; const forwardDirection = new THREE.Vector3(); camera.getWorldDirection(forwardDirection); forwardDirection.y = 0; forwardDirection.normalize(); const rightDirection = new THREE.Vector3(); rightDirection.crossVectors(camera.up, forwardDirection).normalize(); if (moveForward) playerVelocity.addScaledVector(forwardDirection, moveSpeed * delta); if (moveBackward) playerVelocity.addScaledVector(forwardDirection, -moveSpeed * delta); if (moveLeft) playerVelocity.addScaledVector(rightDirection, -moveSpeed * delta); if (moveRight) playerVelocity.addScaledVector(rightDirection, moveSpeed * delta); let isOnGround = false; const feetPosition = controls.getObject().position.clone(); feetPosition.y -= playerFeetOffset; const downRay = new THREE.Raycaster(feetPosition, new THREE.Vector3(0, -1, 0), 0, 0.2); const groundIntersects = downRay.intersectObjects(objects.filter(o => o.userData.type === 'ground' || o.userData.structure), false); if (groundIntersects.length > 0) { isOnGround = true; playerVelocity.y = Math.max(0, playerVelocity.y); canJump = true; } else { playerVelocity.y -= gravity * delta; canJump = false; } controls.getObject().position.x += playerVelocity.x * delta; controls.getObject().position.z += playerVelocity.z * delta; controls.getObject().position.y += playerVelocity.y * delta; if (controls.getObject().position.y < playerHeight - playerFeetOffset + 0.1) { const feetRay = new THREE.Raycaster(controls.getObject().position, new THREE.Vector3(0, -1, 0), 0, playerHeight); const floorHit = feetRay.intersectObjects(objects.filter(o => o.userData.type === 'ground' || o.userData.structure), false); if(floorHit.length > 0){ const floorY = floorHit[0].point.y; if(controls.getObject().position.y < floorY + (playerHeight - playerFeetOffset)){ controls.getObject().position.y = floorY + (playerHeight - playerFeetOffset); playerVelocity.y = 0; canJump = true; } } else { if (controls.getObject().position.y < (playerHeight - playerFeetOffset)){ controls.getObject().position.y = playerHeight - playerFeetOffset; playerVelocity.y = 0; canJump = true; } } } checkInteraction(); } else { playerVelocity.set(0, 0, 0); } renderer.render(scene, camera); }

            // --- Game Start Logic ---
            startButton.addEventListener('click', () => {
                // Get values from inputs
                const treesInput = document.getElementById('num-trees-input');
                const rocksInput = document.getElementById('num-rocks-input');
                const barrelsInput = document.getElementById('num-barrels-input');

                // Parse and validate (use defaults if invalid)
                let treeCount = parseInt(treesInput.value, 10);
                let rockCount = parseInt(rocksInput.value, 10);
                let barrelCount = parseInt(barrelsInput.value, 10);

                NUM_TREES = (!isNaN(treeCount) && treeCount >= 0) ? treeCount : 100; // Use default if NaN or negative
                NUM_ROCKS = (!isNaN(rockCount) && rockCount >= 0) ? rockCount : 80;
                NUM_BARRELS = (!isNaN(barrelCount) && barrelCount >= 0) ? barrelCount : 15;

                // Clamp to max values if they exist
                const maxTrees = parseInt(treesInput.max, 10);
                const maxRocks = parseInt(rocksInput.max, 10);
                const maxBarrels = parseInt(barrelsInput.max, 10);
                if (!isNaN(maxTrees)) NUM_TREES = Math.min(NUM_TREES, maxTrees);
                if (!isNaN(maxRocks)) NUM_ROCKS = Math.min(NUM_ROCKS, maxRocks);
                if (!isNaN(maxBarrels)) NUM_BARRELS = Math.min(NUM_BARRELS, maxBarrels);


                // Hide the configuration screen
                blocker.style.display = 'none';

                // Initialize the game world and systems
                init();

                // Start the animation loop
                animate();

                // Request pointer lock to start playing
                // Needs a slight delay sometimes for the browser to register the UI change
                setTimeout(() => {
                    if(controls) controls.lock();
                }, 100);
            });

        } // End of else block (if THREE is defined)
    </script>
</body>
</html>